"""
Delegates a resolver to a remote schema.
"""
directive @delegate(
  """
  The path to the field on the remote schema.
  """
  path: String

  """
  The name of the schema to which this field shall be delegated to.
  """
  schema: String!
) on FIELD_DEFINITION

directive @computed(
  """
  Specifies the fields on which a computed field is dependent on.
  """
  dependantOn: [String!]
) on FIELD_DEFINITION

"""
Annotates the original name of a type.
"""
directive @source(
  """
  The original name of the annotated type.
  """
  name: String!

  """
  The name of the schema to which this type belongs to.
  """
  schema: String!
) repeatable on OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INTERFACE | UNION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
  """
  measured in seconds
  """
  ttl: Int! = 60

  """
  refresh the cache entry
  """
  refresh: Boolean! = false
) on QUERY

scalar DateTime

scalar UUID

scalar timestamptz

scalar uuid

scalar jsonb

type Query {
  """
  fetch data from the table: "AgentEvaluations"
  """
  agentEvaluations(
    """
    distinct select on columns
    """
    distinctOn: [AgentEvaluationsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AgentEvaluationsOrderBy!]

    """
    filter the rows returned
    """
    where: AgentEvaluationsBoolExp
  ): [AgentEvaluations!]!

  """
  fetch aggregated fields from the table: "AgentEvaluations"
  """
  agentEvaluationsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AgentEvaluationsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AgentEvaluationsOrderBy!]

    """
    filter the rows returned
    """
    where: AgentEvaluationsBoolExp
  ): AgentEvaluationsAggregate!

  """
  fetch data from the table: "AgentEvaluations" using primary key columns
  """
  agentEvaluationsByPk(guid: uuid!): AgentEvaluations

  """
  An array relationship
  """
  lexEntrys(
    """
    distinct select on columns
    """
    distinctOn: [LexEntrysSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexEntrysOrderBy!]

    """
    filter the rows returned
    """
    where: LexEntrysBoolExp
  ): [LexEntrys!]!

  """
  An aggregate relationship
  """
  lexEntrysAggregate(
    """
    distinct select on columns
    """
    distinctOn: [LexEntrysSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexEntrysOrderBy!]

    """
    filter the rows returned
    """
    where: LexEntrysBoolExp
  ): LexEntrysAggregate!

  """
  fetch data from the table: "LexEntrys" using primary key columns
  """
  lexEntrysByPk(guid: uuid!): LexEntrys

  """
  An array relationship
  """
  lexExampleSentences(
    """
    distinct select on columns
    """
    distinctOn: [LexExampleSentencesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexExampleSentencesOrderBy!]

    """
    filter the rows returned
    """
    where: LexExampleSentencesBoolExp
  ): [LexExampleSentences!]!

  """
  An aggregate relationship
  """
  lexExampleSentencesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [LexExampleSentencesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexExampleSentencesOrderBy!]

    """
    filter the rows returned
    """
    where: LexExampleSentencesBoolExp
  ): LexExampleSentencesAggregate!

  """
  fetch data from the table: "LexExampleSentences" using primary key columns
  """
  lexExampleSentencesByPk(guid: uuid!): LexExampleSentences

  """
  An array relationship
  """
  lexExtendedNotes(
    """
    distinct select on columns
    """
    distinctOn: [LexExtendedNotesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexExtendedNotesOrderBy!]

    """
    filter the rows returned
    """
    where: LexExtendedNotesBoolExp
  ): [LexExtendedNotes!]!

  """
  An aggregate relationship
  """
  lexExtendedNotesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [LexExtendedNotesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexExtendedNotesOrderBy!]

    """
    filter the rows returned
    """
    where: LexExtendedNotesBoolExp
  ): LexExtendedNotesAggregate!

  """
  fetch data from the table: "LexExtendedNotes" using primary key columns
  """
  lexExtendedNotesByPk(guid: uuid!): LexExtendedNotes

  """
  An array relationship
  """
  lexSenses(
    """
    distinct select on columns
    """
    distinctOn: [LexSensesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexSensesOrderBy!]

    """
    filter the rows returned
    """
    where: LexSensesBoolExp
  ): [LexSenses!]!

  """
  An aggregate relationship
  """
  lexSensesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [LexSensesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexSensesOrderBy!]

    """
    filter the rows returned
    """
    where: LexSensesBoolExp
  ): LexSensesAggregate!

  """
  fetch data from the table: "LexSenses" using primary key columns
  """
  lexSensesByPk(guid: uuid!): LexSenses

  """
  fetch data from the table: "MoForms"
  """
  moForms(
    """
    distinct select on columns
    """
    distinctOn: [MoFormsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [MoFormsOrderBy!]

    """
    filter the rows returned
    """
    where: MoFormsBoolExp
  ): [MoForms!]!

  """
  fetch aggregated fields from the table: "MoForms"
  """
  moFormsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [MoFormsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [MoFormsOrderBy!]

    """
    filter the rows returned
    """
    where: MoFormsBoolExp
  ): MoFormsAggregate!

  """
  fetch data from the table: "MoForms" using primary key columns
  """
  moFormsByPk(guid: uuid!): MoForms

  """
  fetch data from the table: "MoMorphSynAnalysiss"
  """
  moMorphSynAnalysiss(
    """
    distinct select on columns
    """
    distinctOn: [MoMorphSynAnalysissSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [MoMorphSynAnalysissOrderBy!]

    """
    filter the rows returned
    """
    where: MoMorphSynAnalysissBoolExp
  ): [MoMorphSynAnalysiss!]!

  """
  fetch aggregated fields from the table: "MoMorphSynAnalysiss"
  """
  moMorphSynAnalysissAggregate(
    """
    distinct select on columns
    """
    distinctOn: [MoMorphSynAnalysissSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [MoMorphSynAnalysissOrderBy!]

    """
    filter the rows returned
    """
    where: MoMorphSynAnalysissBoolExp
  ): MoMorphSynAnalysissAggregate!

  """
  fetch data from the table: "MoMorphSynAnalysiss" using primary key columns
  """
  moMorphSynAnalysissByPk(guid: uuid!): MoMorphSynAnalysiss

  """
  fetch data from the table: "Notes"
  """
  notes(
    """
    distinct select on columns
    """
    distinctOn: [NotesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [NotesOrderBy!]

    """
    filter the rows returned
    """
    where: NotesBoolExp
  ): [Notes!]!

  """
  fetch aggregated fields from the table: "Notes"
  """
  notesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [NotesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [NotesOrderBy!]

    """
    filter the rows returned
    """
    where: NotesBoolExp
  ): NotesAggregate!

  """
  fetch data from the table: "Notes" using primary key columns
  """
  notesByPk(guid: uuid!): Notes

  """
  fetch data from the table: "Possibilitys"
  """
  possibilitys(
    """
    distinct select on columns
    """
    distinctOn: [PossibilitysSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PossibilitysOrderBy!]

    """
    filter the rows returned
    """
    where: PossibilitysBoolExp
  ): [Possibilitys!]!

  """
  fetch aggregated fields from the table: "Possibilitys"
  """
  possibilitysAggregate(
    """
    distinct select on columns
    """
    distinctOn: [PossibilitysSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PossibilitysOrderBy!]

    """
    filter the rows returned
    """
    where: PossibilitysBoolExp
  ): PossibilitysAggregate!

  """
  fetch data from the table: "Possibilitys" using primary key columns
  """
  possibilitysByPk(guid: uuid!): Possibilitys

  """
  fetch data from the table: "ProjectUsers"
  """
  projectUsers(
    """
    distinct select on columns
    """
    distinctOn: [ProjectUsersSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ProjectUsersOrderBy!]

    """
    filter the rows returned
    """
    where: ProjectUsersBoolExp
  ): [ProjectUsers!]!

  """
  An aggregate relationship
  """
  projectUsersAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ProjectUsersSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ProjectUsersOrderBy!]

    """
    filter the rows returned
    """
    where: ProjectUsersBoolExp
  ): ProjectUsersAggregate!

  """
  fetch data from the table: "ProjectUsers" using primary key columns
  """
  projectUsersByPk(id: uuid!): ProjectUsers

  """
  fetch data from the table: "Projects"
  """
  projects(
    """
    distinct select on columns
    """
    distinctOn: [ProjectsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ProjectsOrderBy!]

    """
    filter the rows returned
    """
    where: ProjectsBoolExp
  ): [Projects!]!

  """
  fetch aggregated fields from the table: "Projects"
  """
  projectsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ProjectsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ProjectsOrderBy!]

    """
    filter the rows returned
    """
    where: ProjectsBoolExp
  ): ProjectsAggregate!

  """
  fetch data from the table: "Projects" using primary key columns
  """
  projectsByPk(id: uuid!): Projects

  """
  An array relationship
  """
  translations(
    """
    distinct select on columns
    """
    distinctOn: [TranslationsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [TranslationsOrderBy!]

    """
    filter the rows returned
    """
    where: TranslationsBoolExp
  ): [Translations!]!

  """
  An aggregate relationship
  """
  translationsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [TranslationsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [TranslationsOrderBy!]

    """
    filter the rows returned
    """
    where: TranslationsBoolExp
  ): TranslationsAggregate!

  """
  fetch data from the table: "Translations" using primary key columns
  """
  translationsByPk(guid: uuid!): Translations

  """
  fetch data from the table: "Users"
  """
  users(
    """
    distinct select on columns
    """
    distinctOn: [UsersSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UsersOrderBy!]

    """
    filter the rows returned
    """
    where: UsersBoolExp
  ): [Users!]!

  """
  fetch aggregated fields from the table: "Users"
  """
  usersAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UsersSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UsersOrderBy!]

    """
    filter the rows returned
    """
    where: UsersBoolExp
  ): UsersAggregate!

  """
  fetch data from the table: "Users" using primary key columns
  """
  usersByPk(id: uuid!): Users
  myProjects(where: ProjectFilterInput): [Project!]!
  me: LexAuthUser!
}

type Mutation {
  """
  delete data from the table: "AgentEvaluations"
  """
  deleteAgentEvaluations(
    """
    filter the rows which have to be deleted
    """
    where: AgentEvaluationsBoolExp!
  ): AgentEvaluationsMutationResponse

  """
  delete single row from the table: "AgentEvaluations"
  """
  deleteAgentEvaluationsByPk(guid: uuid!): AgentEvaluations

  """
  delete data from the table: "LexEntrys"
  """
  deleteLexEntrys(
    """
    filter the rows which have to be deleted
    """
    where: LexEntrysBoolExp!
  ): LexEntrysMutationResponse

  """
  delete single row from the table: "LexEntrys"
  """
  deleteLexEntrysByPk(guid: uuid!): LexEntrys

  """
  delete data from the table: "LexExampleSentences"
  """
  deleteLexExampleSentences(
    """
    filter the rows which have to be deleted
    """
    where: LexExampleSentencesBoolExp!
  ): LexExampleSentencesMutationResponse

  """
  delete single row from the table: "LexExampleSentences"
  """
  deleteLexExampleSentencesByPk(guid: uuid!): LexExampleSentences

  """
  delete data from the table: "LexExtendedNotes"
  """
  deleteLexExtendedNotes(
    """
    filter the rows which have to be deleted
    """
    where: LexExtendedNotesBoolExp!
  ): LexExtendedNotesMutationResponse

  """
  delete single row from the table: "LexExtendedNotes"
  """
  deleteLexExtendedNotesByPk(guid: uuid!): LexExtendedNotes

  """
  delete data from the table: "LexSenses"
  """
  deleteLexSenses(
    """
    filter the rows which have to be deleted
    """
    where: LexSensesBoolExp!
  ): LexSensesMutationResponse

  """
  delete single row from the table: "LexSenses"
  """
  deleteLexSensesByPk(guid: uuid!): LexSenses

  """
  delete data from the table: "MoForms"
  """
  deleteMoForms(
    """
    filter the rows which have to be deleted
    """
    where: MoFormsBoolExp!
  ): MoFormsMutationResponse

  """
  delete single row from the table: "MoForms"
  """
  deleteMoFormsByPk(guid: uuid!): MoForms

  """
  delete data from the table: "MoMorphSynAnalysiss"
  """
  deleteMoMorphSynAnalysiss(
    """
    filter the rows which have to be deleted
    """
    where: MoMorphSynAnalysissBoolExp!
  ): MoMorphSynAnalysissMutationResponse

  """
  delete single row from the table: "MoMorphSynAnalysiss"
  """
  deleteMoMorphSynAnalysissByPk(guid: uuid!): MoMorphSynAnalysiss

  """
  delete data from the table: "Notes"
  """
  deleteNotes(
    """
    filter the rows which have to be deleted
    """
    where: NotesBoolExp!
  ): NotesMutationResponse

  """
  delete single row from the table: "Notes"
  """
  deleteNotesByPk(guid: uuid!): Notes

  """
  delete data from the table: "Possibilitys"
  """
  deletePossibilitys(
    """
    filter the rows which have to be deleted
    """
    where: PossibilitysBoolExp!
  ): PossibilitysMutationResponse

  """
  delete single row from the table: "Possibilitys"
  """
  deletePossibilitysByPk(guid: uuid!): Possibilitys

  """
  delete data from the table: "ProjectUsers"
  """
  deleteProjectUsers(
    """
    filter the rows which have to be deleted
    """
    where: ProjectUsersBoolExp!
  ): ProjectUsersMutationResponse

  """
  delete single row from the table: "ProjectUsers"
  """
  deleteProjectUsersByPk(id: uuid!): ProjectUsers

  """
  delete data from the table: "Projects"
  """
  deleteProjects(
    """
    filter the rows which have to be deleted
    """
    where: ProjectsBoolExp!
  ): ProjectsMutationResponse

  """
  delete single row from the table: "Projects"
  """
  deleteProjectsByPk(id: uuid!): Projects

  """
  delete data from the table: "Translations"
  """
  deleteTranslations(
    """
    filter the rows which have to be deleted
    """
    where: TranslationsBoolExp!
  ): TranslationsMutationResponse

  """
  delete single row from the table: "Translations"
  """
  deleteTranslationsByPk(guid: uuid!): Translations

  """
  delete data from the table: "Users"
  """
  deleteUsers(
    """
    filter the rows which have to be deleted
    """
    where: UsersBoolExp!
  ): UsersMutationResponse

  """
  delete single row from the table: "Users"
  """
  deleteUsersByPk(id: uuid!): Users

  """
  insert data into the table: "AgentEvaluations"
  """
  insertAgentEvaluations(
    """
    the rows to be inserted
    """
    objects: [AgentEvaluationsInsertInput!]!

    """
    upsert condition
    """
    onConflict: AgentEvaluationsOnConflict
  ): AgentEvaluationsMutationResponse

  """
  insert a single row into the table: "AgentEvaluations"
  """
  insertAgentEvaluationsOne(
    """
    the row to be inserted
    """
    object: AgentEvaluationsInsertInput!

    """
    upsert condition
    """
    onConflict: AgentEvaluationsOnConflict
  ): AgentEvaluations

  """
  insert data into the table: "LexEntrys"
  """
  insertLexEntrys(
    """
    the rows to be inserted
    """
    objects: [LexEntrysInsertInput!]!

    """
    upsert condition
    """
    onConflict: LexEntrysOnConflict
  ): LexEntrysMutationResponse

  """
  insert a single row into the table: "LexEntrys"
  """
  insertLexEntrysOne(
    """
    the row to be inserted
    """
    object: LexEntrysInsertInput!

    """
    upsert condition
    """
    onConflict: LexEntrysOnConflict
  ): LexEntrys

  """
  insert data into the table: "LexExampleSentences"
  """
  insertLexExampleSentences(
    """
    the rows to be inserted
    """
    objects: [LexExampleSentencesInsertInput!]!

    """
    upsert condition
    """
    onConflict: LexExampleSentencesOnConflict
  ): LexExampleSentencesMutationResponse

  """
  insert a single row into the table: "LexExampleSentences"
  """
  insertLexExampleSentencesOne(
    """
    the row to be inserted
    """
    object: LexExampleSentencesInsertInput!

    """
    upsert condition
    """
    onConflict: LexExampleSentencesOnConflict
  ): LexExampleSentences

  """
  insert data into the table: "LexExtendedNotes"
  """
  insertLexExtendedNotes(
    """
    the rows to be inserted
    """
    objects: [LexExtendedNotesInsertInput!]!

    """
    upsert condition
    """
    onConflict: LexExtendedNotesOnConflict
  ): LexExtendedNotesMutationResponse

  """
  insert a single row into the table: "LexExtendedNotes"
  """
  insertLexExtendedNotesOne(
    """
    the row to be inserted
    """
    object: LexExtendedNotesInsertInput!

    """
    upsert condition
    """
    onConflict: LexExtendedNotesOnConflict
  ): LexExtendedNotes

  """
  insert data into the table: "LexSenses"
  """
  insertLexSenses(
    """
    the rows to be inserted
    """
    objects: [LexSensesInsertInput!]!

    """
    upsert condition
    """
    onConflict: LexSensesOnConflict
  ): LexSensesMutationResponse

  """
  insert a single row into the table: "LexSenses"
  """
  insertLexSensesOne(
    """
    the row to be inserted
    """
    object: LexSensesInsertInput!

    """
    upsert condition
    """
    onConflict: LexSensesOnConflict
  ): LexSenses

  """
  insert data into the table: "MoForms"
  """
  insertMoForms(
    """
    the rows to be inserted
    """
    objects: [MoFormsInsertInput!]!

    """
    upsert condition
    """
    onConflict: MoFormsOnConflict
  ): MoFormsMutationResponse

  """
  insert a single row into the table: "MoForms"
  """
  insertMoFormsOne(
    """
    the row to be inserted
    """
    object: MoFormsInsertInput!

    """
    upsert condition
    """
    onConflict: MoFormsOnConflict
  ): MoForms

  """
  insert data into the table: "MoMorphSynAnalysiss"
  """
  insertMoMorphSynAnalysiss(
    """
    the rows to be inserted
    """
    objects: [MoMorphSynAnalysissInsertInput!]!

    """
    upsert condition
    """
    onConflict: MoMorphSynAnalysissOnConflict
  ): MoMorphSynAnalysissMutationResponse

  """
  insert a single row into the table: "MoMorphSynAnalysiss"
  """
  insertMoMorphSynAnalysissOne(
    """
    the row to be inserted
    """
    object: MoMorphSynAnalysissInsertInput!

    """
    upsert condition
    """
    onConflict: MoMorphSynAnalysissOnConflict
  ): MoMorphSynAnalysiss

  """
  insert data into the table: "Notes"
  """
  insertNotes(
    """
    the rows to be inserted
    """
    objects: [NotesInsertInput!]!

    """
    upsert condition
    """
    onConflict: NotesOnConflict
  ): NotesMutationResponse

  """
  insert a single row into the table: "Notes"
  """
  insertNotesOne(
    """
    the row to be inserted
    """
    object: NotesInsertInput!

    """
    upsert condition
    """
    onConflict: NotesOnConflict
  ): Notes

  """
  insert data into the table: "Possibilitys"
  """
  insertPossibilitys(
    """
    the rows to be inserted
    """
    objects: [PossibilitysInsertInput!]!

    """
    upsert condition
    """
    onConflict: PossibilitysOnConflict
  ): PossibilitysMutationResponse

  """
  insert a single row into the table: "Possibilitys"
  """
  insertPossibilitysOne(
    """
    the row to be inserted
    """
    object: PossibilitysInsertInput!

    """
    upsert condition
    """
    onConflict: PossibilitysOnConflict
  ): Possibilitys

  """
  insert data into the table: "ProjectUsers"
  """
  insertProjectUsers(
    """
    the rows to be inserted
    """
    objects: [ProjectUsersInsertInput!]!

    """
    upsert condition
    """
    onConflict: ProjectUsersOnConflict
  ): ProjectUsersMutationResponse

  """
  insert a single row into the table: "ProjectUsers"
  """
  insertProjectUsersOne(
    """
    the row to be inserted
    """
    object: ProjectUsersInsertInput!

    """
    upsert condition
    """
    onConflict: ProjectUsersOnConflict
  ): ProjectUsers

  """
  insert data into the table: "Projects"
  """
  insertProjects(
    """
    the rows to be inserted
    """
    objects: [ProjectsInsertInput!]!

    """
    upsert condition
    """
    onConflict: ProjectsOnConflict
  ): ProjectsMutationResponse

  """
  insert a single row into the table: "Projects"
  """
  insertProjectsOne(
    """
    the row to be inserted
    """
    object: ProjectsInsertInput!

    """
    upsert condition
    """
    onConflict: ProjectsOnConflict
  ): Projects

  """
  insert data into the table: "Translations"
  """
  insertTranslations(
    """
    the rows to be inserted
    """
    objects: [TranslationsInsertInput!]!

    """
    upsert condition
    """
    onConflict: TranslationsOnConflict
  ): TranslationsMutationResponse

  """
  insert a single row into the table: "Translations"
  """
  insertTranslationsOne(
    """
    the row to be inserted
    """
    object: TranslationsInsertInput!

    """
    upsert condition
    """
    onConflict: TranslationsOnConflict
  ): Translations

  """
  insert data into the table: "Users"
  """
  insertUsers(
    """
    the rows to be inserted
    """
    objects: [UsersInsertInput!]!

    """
    upsert condition
    """
    onConflict: UsersOnConflict
  ): UsersMutationResponse

  """
  insert a single row into the table: "Users"
  """
  insertUsersOne(
    """
    the row to be inserted
    """
    object: UsersInsertInput!

    """
    upsert condition
    """
    onConflict: UsersOnConflict
  ): Users

  """
  update data of the table: "AgentEvaluations"
  """
  updateAgentEvaluations(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: AgentEvaluationsIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: AgentEvaluationsSetInput

    """
    filter the rows which have to be updated
    """
    where: AgentEvaluationsBoolExp!
  ): AgentEvaluationsMutationResponse

  """
  update single row of the table: "AgentEvaluations"
  """
  updateAgentEvaluationsByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: AgentEvaluationsIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: AgentEvaluationsSetInput
    pk_columns: AgentEvaluationsPkColumnsInput!
  ): AgentEvaluations

  """
  update multiples rows of table: "AgentEvaluations"
  """
  updateAgentEvaluationsMany(
    """
    updates to execute, in order
    """
    updates: [AgentEvaluationsUpdates!]!
  ): [AgentEvaluationsMutationResponse]

  """
  update data of the table: "LexEntrys"
  """
  updateLexEntrys(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: LexEntrysAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: LexEntrysDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: LexEntrysDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: LexEntrysDeleteKeyInput

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: LexEntrysIncInput

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: LexEntrysPrependInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: LexEntrysSetInput

    """
    filter the rows which have to be updated
    """
    where: LexEntrysBoolExp!
  ): LexEntrysMutationResponse

  """
  update single row of the table: "LexEntrys"
  """
  updateLexEntrysByPk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: LexEntrysAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: LexEntrysDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: LexEntrysDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: LexEntrysDeleteKeyInput

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: LexEntrysIncInput

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: LexEntrysPrependInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: LexEntrysSetInput
    pk_columns: LexEntrysPkColumnsInput!
  ): LexEntrys

  """
  update multiples rows of table: "LexEntrys"
  """
  updateLexEntrysMany(
    """
    updates to execute, in order
    """
    updates: [LexEntrysUpdates!]!
  ): [LexEntrysMutationResponse]

  """
  update data of the table: "LexExampleSentences"
  """
  updateLexExampleSentences(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: LexExampleSentencesAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: LexExampleSentencesDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: LexExampleSentencesDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: LexExampleSentencesDeleteKeyInput

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: LexExampleSentencesIncInput

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: LexExampleSentencesPrependInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: LexExampleSentencesSetInput

    """
    filter the rows which have to be updated
    """
    where: LexExampleSentencesBoolExp!
  ): LexExampleSentencesMutationResponse

  """
  update single row of the table: "LexExampleSentences"
  """
  updateLexExampleSentencesByPk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: LexExampleSentencesAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: LexExampleSentencesDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: LexExampleSentencesDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: LexExampleSentencesDeleteKeyInput

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: LexExampleSentencesIncInput

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: LexExampleSentencesPrependInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: LexExampleSentencesSetInput
    pk_columns: LexExampleSentencesPkColumnsInput!
  ): LexExampleSentences

  """
  update multiples rows of table: "LexExampleSentences"
  """
  updateLexExampleSentencesMany(
    """
    updates to execute, in order
    """
    updates: [LexExampleSentencesUpdates!]!
  ): [LexExampleSentencesMutationResponse]

  """
  update data of the table: "LexExtendedNotes"
  """
  updateLexExtendedNotes(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: LexExtendedNotesAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: LexExtendedNotesDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: LexExtendedNotesDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: LexExtendedNotesDeleteKeyInput

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: LexExtendedNotesIncInput

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: LexExtendedNotesPrependInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: LexExtendedNotesSetInput

    """
    filter the rows which have to be updated
    """
    where: LexExtendedNotesBoolExp!
  ): LexExtendedNotesMutationResponse

  """
  update single row of the table: "LexExtendedNotes"
  """
  updateLexExtendedNotesByPk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: LexExtendedNotesAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: LexExtendedNotesDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: LexExtendedNotesDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: LexExtendedNotesDeleteKeyInput

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: LexExtendedNotesIncInput

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: LexExtendedNotesPrependInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: LexExtendedNotesSetInput
    pk_columns: LexExtendedNotesPkColumnsInput!
  ): LexExtendedNotes

  """
  update multiples rows of table: "LexExtendedNotes"
  """
  updateLexExtendedNotesMany(
    """
    updates to execute, in order
    """
    updates: [LexExtendedNotesUpdates!]!
  ): [LexExtendedNotesMutationResponse]

  """
  update data of the table: "LexSenses"
  """
  updateLexSenses(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: LexSensesAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: LexSensesDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: LexSensesDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: LexSensesDeleteKeyInput

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: LexSensesIncInput

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: LexSensesPrependInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: LexSensesSetInput

    """
    filter the rows which have to be updated
    """
    where: LexSensesBoolExp!
  ): LexSensesMutationResponse

  """
  update single row of the table: "LexSenses"
  """
  updateLexSensesByPk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: LexSensesAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: LexSensesDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: LexSensesDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: LexSensesDeleteKeyInput

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: LexSensesIncInput

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: LexSensesPrependInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: LexSensesSetInput
    pk_columns: LexSensesPkColumnsInput!
  ): LexSenses

  """
  update multiples rows of table: "LexSenses"
  """
  updateLexSensesMany(
    """
    updates to execute, in order
    """
    updates: [LexSensesUpdates!]!
  ): [LexSensesMutationResponse]

  """
  update data of the table: "MoForms"
  """
  updateMoForms(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: MoFormsAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: MoFormsDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: MoFormsDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: MoFormsDeleteKeyInput

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: MoFormsIncInput

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: MoFormsPrependInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: MoFormsSetInput

    """
    filter the rows which have to be updated
    """
    where: MoFormsBoolExp!
  ): MoFormsMutationResponse

  """
  update single row of the table: "MoForms"
  """
  updateMoFormsByPk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: MoFormsAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: MoFormsDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: MoFormsDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: MoFormsDeleteKeyInput

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: MoFormsIncInput

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: MoFormsPrependInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: MoFormsSetInput
    pk_columns: MoFormsPkColumnsInput!
  ): MoForms

  """
  update multiples rows of table: "MoForms"
  """
  updateMoFormsMany(
    """
    updates to execute, in order
    """
    updates: [MoFormsUpdates!]!
  ): [MoFormsMutationResponse]

  """
  update data of the table: "MoMorphSynAnalysiss"
  """
  updateMoMorphSynAnalysiss(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: MoMorphSynAnalysissIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: MoMorphSynAnalysissSetInput

    """
    filter the rows which have to be updated
    """
    where: MoMorphSynAnalysissBoolExp!
  ): MoMorphSynAnalysissMutationResponse

  """
  update single row of the table: "MoMorphSynAnalysiss"
  """
  updateMoMorphSynAnalysissByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: MoMorphSynAnalysissIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: MoMorphSynAnalysissSetInput
    pk_columns: MoMorphSynAnalysissPkColumnsInput!
  ): MoMorphSynAnalysiss

  """
  update multiples rows of table: "MoMorphSynAnalysiss"
  """
  updateMoMorphSynAnalysissMany(
    """
    updates to execute, in order
    """
    updates: [MoMorphSynAnalysissUpdates!]!
  ): [MoMorphSynAnalysissMutationResponse]

  """
  update data of the table: "Notes"
  """
  updateNotes(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: NotesAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: NotesDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: NotesDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: NotesDeleteKeyInput

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: NotesIncInput

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: NotesPrependInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: NotesSetInput

    """
    filter the rows which have to be updated
    """
    where: NotesBoolExp!
  ): NotesMutationResponse

  """
  update single row of the table: "Notes"
  """
  updateNotesByPk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: NotesAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: NotesDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: NotesDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: NotesDeleteKeyInput

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: NotesIncInput

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: NotesPrependInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: NotesSetInput
    pk_columns: NotesPkColumnsInput!
  ): Notes

  """
  update multiples rows of table: "Notes"
  """
  updateNotesMany(
    """
    updates to execute, in order
    """
    updates: [NotesUpdates!]!
  ): [NotesMutationResponse]

  """
  update data of the table: "Possibilitys"
  """
  updatePossibilitys(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: PossibilitysAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: PossibilitysDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: PossibilitysDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: PossibilitysDeleteKeyInput

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: PossibilitysIncInput

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: PossibilitysPrependInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: PossibilitysSetInput

    """
    filter the rows which have to be updated
    """
    where: PossibilitysBoolExp!
  ): PossibilitysMutationResponse

  """
  update single row of the table: "Possibilitys"
  """
  updatePossibilitysByPk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: PossibilitysAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: PossibilitysDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: PossibilitysDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: PossibilitysDeleteKeyInput

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: PossibilitysIncInput

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: PossibilitysPrependInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: PossibilitysSetInput
    pk_columns: PossibilitysPkColumnsInput!
  ): Possibilitys

  """
  update multiples rows of table: "Possibilitys"
  """
  updatePossibilitysMany(
    """
    updates to execute, in order
    """
    updates: [PossibilitysUpdates!]!
  ): [PossibilitysMutationResponse]

  """
  update data of the table: "ProjectUsers"
  """
  updateProjectUsers(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ProjectUsersIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ProjectUsersSetInput

    """
    filter the rows which have to be updated
    """
    where: ProjectUsersBoolExp!
  ): ProjectUsersMutationResponse

  """
  update single row of the table: "ProjectUsers"
  """
  updateProjectUsersByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ProjectUsersIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ProjectUsersSetInput
    pk_columns: ProjectUsersPkColumnsInput!
  ): ProjectUsers

  """
  update multiples rows of table: "ProjectUsers"
  """
  updateProjectUsersMany(
    """
    updates to execute, in order
    """
    updates: [ProjectUsersUpdates!]!
  ): [ProjectUsersMutationResponse]

  """
  update data of the table: "Projects"
  """
  updateProjects(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ProjectsIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ProjectsSetInput

    """
    filter the rows which have to be updated
    """
    where: ProjectsBoolExp!
  ): ProjectsMutationResponse

  """
  update single row of the table: "Projects"
  """
  updateProjectsByPk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: ProjectsIncInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: ProjectsSetInput
    pk_columns: ProjectsPkColumnsInput!
  ): Projects

  """
  update multiples rows of table: "Projects"
  """
  updateProjectsMany(
    """
    updates to execute, in order
    """
    updates: [ProjectsUpdates!]!
  ): [ProjectsMutationResponse]

  """
  update data of the table: "Translations"
  """
  updateTranslations(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: TranslationsAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: TranslationsDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: TranslationsDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: TranslationsDeleteKeyInput

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: TranslationsIncInput

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: TranslationsPrependInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: TranslationsSetInput

    """
    filter the rows which have to be updated
    """
    where: TranslationsBoolExp!
  ): TranslationsMutationResponse

  """
  update single row of the table: "Translations"
  """
  updateTranslationsByPk(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: TranslationsAppendInput

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _deleteAtPath: TranslationsDeleteAtPathInput

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _deleteElem: TranslationsDeleteElemInput

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _deleteKey: TranslationsDeleteKeyInput

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: TranslationsIncInput

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: TranslationsPrependInput

    """
    sets the columns of the filtered rows to the given values
    """
    _set: TranslationsSetInput
    pk_columns: TranslationsPkColumnsInput!
  ): Translations

  """
  update multiples rows of table: "Translations"
  """
  updateTranslationsMany(
    """
    updates to execute, in order
    """
    updates: [TranslationsUpdates!]!
  ): [TranslationsMutationResponse]

  """
  update data of the table: "Users"
  """
  updateUsers(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: UsersSetInput

    """
    filter the rows which have to be updated
    """
    where: UsersBoolExp!
  ): UsersMutationResponse

  """
  update single row of the table: "Users"
  """
  updateUsersByPk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: UsersSetInput
    pk_columns: UsersPkColumnsInput!
  ): Users

  """
  update multiples rows of table: "Users"
  """
  updateUsersMany(
    """
    updates to execute, in order
    """
    updates: [UsersUpdates!]!
  ): [UsersMutationResponse]
  createProject(input: CreateProjectInput!): Project
}

type Subscription {
  """
  fetch data from the table: "AgentEvaluations"
  """
  agentEvaluations(
    """
    distinct select on columns
    """
    distinctOn: [AgentEvaluationsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AgentEvaluationsOrderBy!]

    """
    filter the rows returned
    """
    where: AgentEvaluationsBoolExp
  ): [AgentEvaluations!]!

  """
  fetch aggregated fields from the table: "AgentEvaluations"
  """
  agentEvaluationsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [AgentEvaluationsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [AgentEvaluationsOrderBy!]

    """
    filter the rows returned
    """
    where: AgentEvaluationsBoolExp
  ): AgentEvaluationsAggregate!

  """
  fetch data from the table: "AgentEvaluations" using primary key columns
  """
  agentEvaluationsByPk(guid: uuid!): AgentEvaluations

  """
  fetch data from the table in a streaming manner: "AgentEvaluations"
  """
  agentEvaluationsStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [AgentEvaluationsStreamCursorInput]!

    """
    filter the rows returned
    """
    where: AgentEvaluationsBoolExp
  ): [AgentEvaluations!]!

  """
  An array relationship
  """
  lexEntrys(
    """
    distinct select on columns
    """
    distinctOn: [LexEntrysSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexEntrysOrderBy!]

    """
    filter the rows returned
    """
    where: LexEntrysBoolExp
  ): [LexEntrys!]!

  """
  An aggregate relationship
  """
  lexEntrysAggregate(
    """
    distinct select on columns
    """
    distinctOn: [LexEntrysSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexEntrysOrderBy!]

    """
    filter the rows returned
    """
    where: LexEntrysBoolExp
  ): LexEntrysAggregate!

  """
  fetch data from the table: "LexEntrys" using primary key columns
  """
  lexEntrysByPk(guid: uuid!): LexEntrys

  """
  fetch data from the table in a streaming manner: "LexEntrys"
  """
  lexEntrysStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [LexEntrysStreamCursorInput]!

    """
    filter the rows returned
    """
    where: LexEntrysBoolExp
  ): [LexEntrys!]!

  """
  An array relationship
  """
  lexExampleSentences(
    """
    distinct select on columns
    """
    distinctOn: [LexExampleSentencesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexExampleSentencesOrderBy!]

    """
    filter the rows returned
    """
    where: LexExampleSentencesBoolExp
  ): [LexExampleSentences!]!

  """
  An aggregate relationship
  """
  lexExampleSentencesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [LexExampleSentencesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexExampleSentencesOrderBy!]

    """
    filter the rows returned
    """
    where: LexExampleSentencesBoolExp
  ): LexExampleSentencesAggregate!

  """
  fetch data from the table: "LexExampleSentences" using primary key columns
  """
  lexExampleSentencesByPk(guid: uuid!): LexExampleSentences

  """
  fetch data from the table in a streaming manner: "LexExampleSentences"
  """
  lexExampleSentencesStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [LexExampleSentencesStreamCursorInput]!

    """
    filter the rows returned
    """
    where: LexExampleSentencesBoolExp
  ): [LexExampleSentences!]!

  """
  An array relationship
  """
  lexExtendedNotes(
    """
    distinct select on columns
    """
    distinctOn: [LexExtendedNotesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexExtendedNotesOrderBy!]

    """
    filter the rows returned
    """
    where: LexExtendedNotesBoolExp
  ): [LexExtendedNotes!]!

  """
  An aggregate relationship
  """
  lexExtendedNotesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [LexExtendedNotesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexExtendedNotesOrderBy!]

    """
    filter the rows returned
    """
    where: LexExtendedNotesBoolExp
  ): LexExtendedNotesAggregate!

  """
  fetch data from the table: "LexExtendedNotes" using primary key columns
  """
  lexExtendedNotesByPk(guid: uuid!): LexExtendedNotes

  """
  fetch data from the table in a streaming manner: "LexExtendedNotes"
  """
  lexExtendedNotesStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [LexExtendedNotesStreamCursorInput]!

    """
    filter the rows returned
    """
    where: LexExtendedNotesBoolExp
  ): [LexExtendedNotes!]!

  """
  An array relationship
  """
  lexSenses(
    """
    distinct select on columns
    """
    distinctOn: [LexSensesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexSensesOrderBy!]

    """
    filter the rows returned
    """
    where: LexSensesBoolExp
  ): [LexSenses!]!

  """
  An aggregate relationship
  """
  lexSensesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [LexSensesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexSensesOrderBy!]

    """
    filter the rows returned
    """
    where: LexSensesBoolExp
  ): LexSensesAggregate!

  """
  fetch data from the table: "LexSenses" using primary key columns
  """
  lexSensesByPk(guid: uuid!): LexSenses

  """
  fetch data from the table in a streaming manner: "LexSenses"
  """
  lexSensesStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [LexSensesStreamCursorInput]!

    """
    filter the rows returned
    """
    where: LexSensesBoolExp
  ): [LexSenses!]!

  """
  fetch data from the table: "MoForms"
  """
  moForms(
    """
    distinct select on columns
    """
    distinctOn: [MoFormsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [MoFormsOrderBy!]

    """
    filter the rows returned
    """
    where: MoFormsBoolExp
  ): [MoForms!]!

  """
  fetch aggregated fields from the table: "MoForms"
  """
  moFormsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [MoFormsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [MoFormsOrderBy!]

    """
    filter the rows returned
    """
    where: MoFormsBoolExp
  ): MoFormsAggregate!

  """
  fetch data from the table: "MoForms" using primary key columns
  """
  moFormsByPk(guid: uuid!): MoForms

  """
  fetch data from the table in a streaming manner: "MoForms"
  """
  moFormsStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [MoFormsStreamCursorInput]!

    """
    filter the rows returned
    """
    where: MoFormsBoolExp
  ): [MoForms!]!

  """
  fetch data from the table: "MoMorphSynAnalysiss"
  """
  moMorphSynAnalysiss(
    """
    distinct select on columns
    """
    distinctOn: [MoMorphSynAnalysissSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [MoMorphSynAnalysissOrderBy!]

    """
    filter the rows returned
    """
    where: MoMorphSynAnalysissBoolExp
  ): [MoMorphSynAnalysiss!]!

  """
  fetch aggregated fields from the table: "MoMorphSynAnalysiss"
  """
  moMorphSynAnalysissAggregate(
    """
    distinct select on columns
    """
    distinctOn: [MoMorphSynAnalysissSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [MoMorphSynAnalysissOrderBy!]

    """
    filter the rows returned
    """
    where: MoMorphSynAnalysissBoolExp
  ): MoMorphSynAnalysissAggregate!

  """
  fetch data from the table: "MoMorphSynAnalysiss" using primary key columns
  """
  moMorphSynAnalysissByPk(guid: uuid!): MoMorphSynAnalysiss

  """
  fetch data from the table in a streaming manner: "MoMorphSynAnalysiss"
  """
  moMorphSynAnalysissStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [MoMorphSynAnalysissStreamCursorInput]!

    """
    filter the rows returned
    """
    where: MoMorphSynAnalysissBoolExp
  ): [MoMorphSynAnalysiss!]!

  """
  fetch data from the table: "Notes"
  """
  notes(
    """
    distinct select on columns
    """
    distinctOn: [NotesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [NotesOrderBy!]

    """
    filter the rows returned
    """
    where: NotesBoolExp
  ): [Notes!]!

  """
  fetch aggregated fields from the table: "Notes"
  """
  notesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [NotesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [NotesOrderBy!]

    """
    filter the rows returned
    """
    where: NotesBoolExp
  ): NotesAggregate!

  """
  fetch data from the table: "Notes" using primary key columns
  """
  notesByPk(guid: uuid!): Notes

  """
  fetch data from the table in a streaming manner: "Notes"
  """
  notesStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [NotesStreamCursorInput]!

    """
    filter the rows returned
    """
    where: NotesBoolExp
  ): [Notes!]!

  """
  fetch data from the table: "Possibilitys"
  """
  possibilitys(
    """
    distinct select on columns
    """
    distinctOn: [PossibilitysSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PossibilitysOrderBy!]

    """
    filter the rows returned
    """
    where: PossibilitysBoolExp
  ): [Possibilitys!]!

  """
  fetch aggregated fields from the table: "Possibilitys"
  """
  possibilitysAggregate(
    """
    distinct select on columns
    """
    distinctOn: [PossibilitysSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [PossibilitysOrderBy!]

    """
    filter the rows returned
    """
    where: PossibilitysBoolExp
  ): PossibilitysAggregate!

  """
  fetch data from the table: "Possibilitys" using primary key columns
  """
  possibilitysByPk(guid: uuid!): Possibilitys

  """
  fetch data from the table in a streaming manner: "Possibilitys"
  """
  possibilitysStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [PossibilitysStreamCursorInput]!

    """
    filter the rows returned
    """
    where: PossibilitysBoolExp
  ): [Possibilitys!]!

  """
  fetch data from the table: "ProjectUsers"
  """
  projectUsers(
    """
    distinct select on columns
    """
    distinctOn: [ProjectUsersSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ProjectUsersOrderBy!]

    """
    filter the rows returned
    """
    where: ProjectUsersBoolExp
  ): [ProjectUsers!]!

  """
  An aggregate relationship
  """
  projectUsersAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ProjectUsersSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ProjectUsersOrderBy!]

    """
    filter the rows returned
    """
    where: ProjectUsersBoolExp
  ): ProjectUsersAggregate!

  """
  fetch data from the table: "ProjectUsers" using primary key columns
  """
  projectUsersByPk(id: uuid!): ProjectUsers

  """
  fetch data from the table in a streaming manner: "ProjectUsers"
  """
  projectUsersStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ProjectUsersStreamCursorInput]!

    """
    filter the rows returned
    """
    where: ProjectUsersBoolExp
  ): [ProjectUsers!]!

  """
  fetch data from the table: "Projects"
  """
  projects(
    """
    distinct select on columns
    """
    distinctOn: [ProjectsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ProjectsOrderBy!]

    """
    filter the rows returned
    """
    where: ProjectsBoolExp
  ): [Projects!]!

  """
  fetch aggregated fields from the table: "Projects"
  """
  projectsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ProjectsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ProjectsOrderBy!]

    """
    filter the rows returned
    """
    where: ProjectsBoolExp
  ): ProjectsAggregate!

  """
  fetch data from the table: "Projects" using primary key columns
  """
  projectsByPk(id: uuid!): Projects

  """
  fetch data from the table in a streaming manner: "Projects"
  """
  projectsStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [ProjectsStreamCursorInput]!

    """
    filter the rows returned
    """
    where: ProjectsBoolExp
  ): [Projects!]!

  """
  An array relationship
  """
  translations(
    """
    distinct select on columns
    """
    distinctOn: [TranslationsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [TranslationsOrderBy!]

    """
    filter the rows returned
    """
    where: TranslationsBoolExp
  ): [Translations!]!

  """
  An aggregate relationship
  """
  translationsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [TranslationsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [TranslationsOrderBy!]

    """
    filter the rows returned
    """
    where: TranslationsBoolExp
  ): TranslationsAggregate!

  """
  fetch data from the table: "Translations" using primary key columns
  """
  translationsByPk(guid: uuid!): Translations

  """
  fetch data from the table in a streaming manner: "Translations"
  """
  translationsStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [TranslationsStreamCursorInput]!

    """
    filter the rows returned
    """
    where: TranslationsBoolExp
  ): [Translations!]!

  """
  fetch data from the table: "Users"
  """
  users(
    """
    distinct select on columns
    """
    distinctOn: [UsersSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UsersOrderBy!]

    """
    filter the rows returned
    """
    where: UsersBoolExp
  ): [Users!]!

  """
  fetch aggregated fields from the table: "Users"
  """
  usersAggregate(
    """
    distinct select on columns
    """
    distinctOn: [UsersSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [UsersOrderBy!]

    """
    filter the rows returned
    """
    where: UsersBoolExp
  ): UsersAggregate!

  """
  fetch data from the table: "Users" using primary key columns
  """
  usersByPk(id: uuid!): Users

  """
  fetch data from the table in a streaming manner: "Users"
  """
  usersStream(
    """
    maximum number of rows returned in a single batch
    """
    batchSize: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [UsersStreamCursorInput]!

    """
    filter the rows returned
    """
    where: UsersBoolExp
  ): [Users!]!
}

"""
columns and relationships of "AgentEvaluations"
"""
type AgentEvaluations {
  classID: Int!
  guid: uuid!
  hvo: Int!
  ownOrd: Int!
  owner: uuid
  owningFlid: Int!
}

"""
aggregated selection of "AgentEvaluations"
"""
type AgentEvaluationsAggregate {
  aggregate: AgentEvaluationsAggregateFields
  nodes: [AgentEvaluations!]!
}

"""
aggregate fields of "AgentEvaluations"
"""
type AgentEvaluationsAggregateFields {
  avg: AgentEvaluationsAvgFields
  count(columns: [AgentEvaluationsSelectColumn!], distinct: Boolean): Int!
  max: AgentEvaluationsMaxFields
  min: AgentEvaluationsMinFields
  stddev: AgentEvaluationsStddevFields
  stddevPop: AgentEvaluationsStddev_popFields
  stddevSamp: AgentEvaluationsStddev_sampFields
  sum: AgentEvaluationsSumFields
  varPop: AgentEvaluationsVar_popFields
  varSamp: AgentEvaluationsVar_sampFields
  variance: AgentEvaluationsVarianceFields
}

"""
aggregate avg on columns
"""
type AgentEvaluationsAvgFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate max on columns
"""
type AgentEvaluationsMaxFields {
  classID: Int
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
}

"""
aggregate min on columns
"""
type AgentEvaluationsMinFields {
  classID: Int
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
}

"""
response of any mutation on the table "AgentEvaluations"
"""
type AgentEvaluationsMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [AgentEvaluations!]!
}

"""
aggregate stddev on columns
"""
type AgentEvaluationsStddevFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate stddev_pop on columns
"""
type AgentEvaluationsStddev_popFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate stddev_samp on columns
"""
type AgentEvaluationsStddev_sampFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate sum on columns
"""
type AgentEvaluationsSumFields {
  classID: Int
  hvo: Int
  ownOrd: Int
  owningFlid: Int
}

"""
aggregate var_pop on columns
"""
type AgentEvaluationsVar_popFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate var_samp on columns
"""
type AgentEvaluationsVar_sampFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate variance on columns
"""
type AgentEvaluationsVarianceFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
columns and relationships of "LexEntrys"
"""
type LexEntrys {
  bibliography(
    """
    JSON select path
    """
    path: String
  ): jsonb
  citationForm(
    """
    JSON select path
    """
    path: String
  ): jsonb
  classID: Int!
  comment(
    """
    JSON select path
    """
    path: String
  ): jsonb
  dateCreated: timestamptz!
  dateModified: timestamptz!
  doNotUseForParsing: Boolean!
  guid: uuid!
  homographNumber: Int!
  hvo: Int!
  importResidue: String

  """
  An array relationship
  """
  lexSenses(
    """
    distinct select on columns
    """
    distinctOn: [LexSensesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexSensesOrderBy!]

    """
    filter the rows returned
    """
    where: LexSensesBoolExp
  ): [LexSenses!]!

  """
  An aggregate relationship
  """
  lexSensesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [LexSensesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexSensesOrderBy!]

    """
    filter the rows returned
    """
    where: LexSensesBoolExp
  ): LexSensesAggregate!
  lexemeFormGuid: uuid
  liftResidue: String
  literalMeaning(
    """
    JSON select path
    """
    path: String
  ): jsonb

  """
  An object relationship
  """
  moForm: MoForms
  ownOrd: Int!
  owner: uuid
  owningFlid: Int!
  restrictions(
    """
    JSON select path
    """
    path: String
  ): jsonb
  summaryDefinition(
    """
    JSON select path
    """
    path: String
  ): jsonb
}

"""
aggregated selection of "LexEntrys"
"""
type LexEntrysAggregate {
  aggregate: LexEntrysAggregateFields
  nodes: [LexEntrys!]!
}

"""
aggregate fields of "LexEntrys"
"""
type LexEntrysAggregateFields {
  avg: LexEntrysAvgFields
  count(columns: [LexEntrysSelectColumn!], distinct: Boolean): Int!
  max: LexEntrysMaxFields
  min: LexEntrysMinFields
  stddev: LexEntrysStddevFields
  stddevPop: LexEntrysStddev_popFields
  stddevSamp: LexEntrysStddev_sampFields
  sum: LexEntrysSumFields
  varPop: LexEntrysVar_popFields
  varSamp: LexEntrysVar_sampFields
  variance: LexEntrysVarianceFields
}

"""
aggregate avg on columns
"""
type LexEntrysAvgFields {
  classID: Float
  homographNumber: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate max on columns
"""
type LexEntrysMaxFields {
  classID: Int
  dateCreated: timestamptz
  dateModified: timestamptz
  guid: uuid
  homographNumber: Int
  hvo: Int
  importResidue: String
  lexemeFormGuid: uuid
  liftResidue: String
  ownOrd: Int
  owner: uuid
  owningFlid: Int
}

"""
aggregate min on columns
"""
type LexEntrysMinFields {
  classID: Int
  dateCreated: timestamptz
  dateModified: timestamptz
  guid: uuid
  homographNumber: Int
  hvo: Int
  importResidue: String
  lexemeFormGuid: uuid
  liftResidue: String
  ownOrd: Int
  owner: uuid
  owningFlid: Int
}

"""
response of any mutation on the table "LexEntrys"
"""
type LexEntrysMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [LexEntrys!]!
}

"""
aggregate stddev on columns
"""
type LexEntrysStddevFields {
  classID: Float
  homographNumber: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate stddev_pop on columns
"""
type LexEntrysStddev_popFields {
  classID: Float
  homographNumber: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate stddev_samp on columns
"""
type LexEntrysStddev_sampFields {
  classID: Float
  homographNumber: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate sum on columns
"""
type LexEntrysSumFields {
  classID: Int
  homographNumber: Int
  hvo: Int
  ownOrd: Int
  owningFlid: Int
}

"""
aggregate var_pop on columns
"""
type LexEntrysVar_popFields {
  classID: Float
  homographNumber: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate var_samp on columns
"""
type LexEntrysVar_sampFields {
  classID: Float
  homographNumber: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate variance on columns
"""
type LexEntrysVarianceFields {
  classID: Float
  homographNumber: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
columns and relationships of "LexExampleSentences"
"""
type LexExampleSentences {
  LexExtendedNote_ExamplesGuid: uuid
  LexSense_ExamplesGuid: uuid
  classID: Int!
  example(
    """
    JSON select path
    """
    path: String
  ): jsonb
  guid: uuid!
  hvo: Int!

  """
  An object relationship
  """
  lexSense: LexSenses
  liftResidue: String
  ownOrd: Int!
  owner: uuid
  owningFlid: Int!
  reference: String

  """
  An array relationship
  """
  translations(
    """
    distinct select on columns
    """
    distinctOn: [TranslationsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [TranslationsOrderBy!]

    """
    filter the rows returned
    """
    where: TranslationsBoolExp
  ): [Translations!]!

  """
  An aggregate relationship
  """
  translationsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [TranslationsSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [TranslationsOrderBy!]

    """
    filter the rows returned
    """
    where: TranslationsBoolExp
  ): TranslationsAggregate!
}

"""
aggregated selection of "LexExampleSentences"
"""
type LexExampleSentencesAggregate {
  aggregate: LexExampleSentencesAggregateFields
  nodes: [LexExampleSentences!]!
}

"""
aggregate fields of "LexExampleSentences"
"""
type LexExampleSentencesAggregateFields {
  avg: LexExampleSentencesAvgFields
  count(columns: [LexExampleSentencesSelectColumn!], distinct: Boolean): Int!
  max: LexExampleSentencesMaxFields
  min: LexExampleSentencesMinFields
  stddev: LexExampleSentencesStddevFields
  stddevPop: LexExampleSentencesStddev_popFields
  stddevSamp: LexExampleSentencesStddev_sampFields
  sum: LexExampleSentencesSumFields
  varPop: LexExampleSentencesVar_popFields
  varSamp: LexExampleSentencesVar_sampFields
  variance: LexExampleSentencesVarianceFields
}

"""
aggregate avg on columns
"""
type LexExampleSentencesAvgFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate max on columns
"""
type LexExampleSentencesMaxFields {
  LexExtendedNote_ExamplesGuid: uuid
  LexSense_ExamplesGuid: uuid
  classID: Int
  guid: uuid
  hvo: Int
  liftResidue: String
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  reference: String
}

"""
aggregate min on columns
"""
type LexExampleSentencesMinFields {
  LexExtendedNote_ExamplesGuid: uuid
  LexSense_ExamplesGuid: uuid
  classID: Int
  guid: uuid
  hvo: Int
  liftResidue: String
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  reference: String
}

"""
response of any mutation on the table "LexExampleSentences"
"""
type LexExampleSentencesMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [LexExampleSentences!]!
}

"""
aggregate stddev on columns
"""
type LexExampleSentencesStddevFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate stddev_pop on columns
"""
type LexExampleSentencesStddev_popFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate stddev_samp on columns
"""
type LexExampleSentencesStddev_sampFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate sum on columns
"""
type LexExampleSentencesSumFields {
  classID: Int
  hvo: Int
  ownOrd: Int
  owningFlid: Int
}

"""
aggregate var_pop on columns
"""
type LexExampleSentencesVar_popFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate var_samp on columns
"""
type LexExampleSentencesVar_sampFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate variance on columns
"""
type LexExampleSentencesVarianceFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
columns and relationships of "LexExtendedNotes"
"""
type LexExtendedNotes {
  LexExtendedNote_ExtendedNoteTypeGuid: uuid
  LexSense_ExtendedNoteGuid: uuid
  classID: Int!
  discussion(
    """
    JSON select path
    """
    path: String
  ): jsonb
  extendedNoteTypeGuid: uuid
  guid: uuid!
  hvo: Int!
  ownOrd: Int!
  owner: uuid
  owningFlid: Int!
}

"""
aggregated selection of "LexExtendedNotes"
"""
type LexExtendedNotesAggregate {
  aggregate: LexExtendedNotesAggregateFields
  nodes: [LexExtendedNotes!]!
}

"""
aggregate fields of "LexExtendedNotes"
"""
type LexExtendedNotesAggregateFields {
  avg: LexExtendedNotesAvgFields
  count(columns: [LexExtendedNotesSelectColumn!], distinct: Boolean): Int!
  max: LexExtendedNotesMaxFields
  min: LexExtendedNotesMinFields
  stddev: LexExtendedNotesStddevFields
  stddevPop: LexExtendedNotesStddev_popFields
  stddevSamp: LexExtendedNotesStddev_sampFields
  sum: LexExtendedNotesSumFields
  varPop: LexExtendedNotesVar_popFields
  varSamp: LexExtendedNotesVar_sampFields
  variance: LexExtendedNotesVarianceFields
}

"""
aggregate avg on columns
"""
type LexExtendedNotesAvgFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate max on columns
"""
type LexExtendedNotesMaxFields {
  LexExtendedNote_ExtendedNoteTypeGuid: uuid
  LexSense_ExtendedNoteGuid: uuid
  classID: Int
  extendedNoteTypeGuid: uuid
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
}

"""
aggregate min on columns
"""
type LexExtendedNotesMinFields {
  LexExtendedNote_ExtendedNoteTypeGuid: uuid
  LexSense_ExtendedNoteGuid: uuid
  classID: Int
  extendedNoteTypeGuid: uuid
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
}

"""
response of any mutation on the table "LexExtendedNotes"
"""
type LexExtendedNotesMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [LexExtendedNotes!]!
}

"""
aggregate stddev on columns
"""
type LexExtendedNotesStddevFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate stddev_pop on columns
"""
type LexExtendedNotesStddev_popFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate stddev_samp on columns
"""
type LexExtendedNotesStddev_sampFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate sum on columns
"""
type LexExtendedNotesSumFields {
  classID: Int
  hvo: Int
  ownOrd: Int
  owningFlid: Int
}

"""
aggregate var_pop on columns
"""
type LexExtendedNotesVar_popFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate var_samp on columns
"""
type LexExtendedNotesVar_sampFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate variance on columns
"""
type LexExtendedNotesVarianceFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
columns and relationships of "LexSenses"
"""
type LexSenses {
  LexEntry_SensesGuid: uuid
  LexSense_MorphoSyntaxAnalysisGuid: uuid
  LexSense_SenseTypeGuid: uuid
  LexSense_SensesGuid: uuid
  LexSense_StatusGuid: uuid
  anthroNote(
    """
    JSON select path
    """
    path: String
  ): jsonb
  bibliography(
    """
    JSON select path
    """
    path: String
  ): jsonb
  classID: Int!
  definition(
    """
    JSON select path
    """
    path: String
  ): jsonb
  discourseNote(
    """
    JSON select path
    """
    path: String
  ): jsonb
  encyclopedicInfo(
    """
    JSON select path
    """
    path: String
  ): jsonb
  exemplar(
    """
    JSON select path
    """
    path: String
  ): jsonb
  generalNote(
    """
    JSON select path
    """
    path: String
  ): jsonb
  gloss(
    """
    JSON select path
    """
    path: String
  ): jsonb
  grammarNote(
    """
    JSON select path
    """
    path: String
  ): jsonb
  guid: uuid!
  hvo: Int!
  importResidue: String

  """
  An object relationship
  """
  lexEntry: LexEntrys

  """
  An array relationship
  """
  lexExampleSentences(
    """
    distinct select on columns
    """
    distinctOn: [LexExampleSentencesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexExampleSentencesOrderBy!]

    """
    filter the rows returned
    """
    where: LexExampleSentencesBoolExp
  ): [LexExampleSentences!]!

  """
  An aggregate relationship
  """
  lexExampleSentencesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [LexExampleSentencesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexExampleSentencesOrderBy!]

    """
    filter the rows returned
    """
    where: LexExampleSentencesBoolExp
  ): LexExampleSentencesAggregate!

  """
  An array relationship
  """
  lexExtendedNotes(
    """
    distinct select on columns
    """
    distinctOn: [LexExtendedNotesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexExtendedNotesOrderBy!]

    """
    filter the rows returned
    """
    where: LexExtendedNotesBoolExp
  ): [LexExtendedNotes!]!

  """
  An aggregate relationship
  """
  lexExtendedNotesAggregate(
    """
    distinct select on columns
    """
    distinctOn: [LexExtendedNotesSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexExtendedNotesOrderBy!]

    """
    filter the rows returned
    """
    where: LexExtendedNotesBoolExp
  ): LexExtendedNotesAggregate!
  liftResidue: String

  """
  An object relationship
  """
  moMorphSynAnalysis: MoMorphSynAnalysiss
  morphoSyntaxAnalysisGuid: uuid
  ownOrd: Int!
  owner: uuid
  owningFlid: Int!
  phonologyNote(
    """
    JSON select path
    """
    path: String
  ): jsonb
  restrictions(
    """
    JSON select path
    """
    path: String
  ): jsonb
  scientificName: String
  semanticsNote(
    """
    JSON select path
    """
    path: String
  ): jsonb

  """
  An object relationship
  """
  senseType: Possibilitys
  senseTypeGuid: uuid
  socioLinguisticsNote(
    """
    JSON select path
    """
    path: String
  ): jsonb
  source: String
  statusGuid: uuid
  usageNote(
    """
    JSON select path
    """
    path: String
  ): jsonb
}

"""
aggregated selection of "LexSenses"
"""
type LexSensesAggregate {
  aggregate: LexSensesAggregateFields
  nodes: [LexSenses!]!
}

"""
aggregate fields of "LexSenses"
"""
type LexSensesAggregateFields {
  avg: LexSensesAvgFields
  count(columns: [LexSensesSelectColumn!], distinct: Boolean): Int!
  max: LexSensesMaxFields
  min: LexSensesMinFields
  stddev: LexSensesStddevFields
  stddevPop: LexSensesStddev_popFields
  stddevSamp: LexSensesStddev_sampFields
  sum: LexSensesSumFields
  varPop: LexSensesVar_popFields
  varSamp: LexSensesVar_sampFields
  variance: LexSensesVarianceFields
}

"""
aggregate avg on columns
"""
type LexSensesAvgFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate max on columns
"""
type LexSensesMaxFields {
  LexEntry_SensesGuid: uuid
  LexSense_MorphoSyntaxAnalysisGuid: uuid
  LexSense_SenseTypeGuid: uuid
  LexSense_SensesGuid: uuid
  LexSense_StatusGuid: uuid
  classID: Int
  guid: uuid
  hvo: Int
  importResidue: String
  liftResidue: String
  morphoSyntaxAnalysisGuid: uuid
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  scientificName: String
  senseTypeGuid: uuid
  source: String
  statusGuid: uuid
}

"""
aggregate min on columns
"""
type LexSensesMinFields {
  LexEntry_SensesGuid: uuid
  LexSense_MorphoSyntaxAnalysisGuid: uuid
  LexSense_SenseTypeGuid: uuid
  LexSense_SensesGuid: uuid
  LexSense_StatusGuid: uuid
  classID: Int
  guid: uuid
  hvo: Int
  importResidue: String
  liftResidue: String
  morphoSyntaxAnalysisGuid: uuid
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  scientificName: String
  senseTypeGuid: uuid
  source: String
  statusGuid: uuid
}

"""
response of any mutation on the table "LexSenses"
"""
type LexSensesMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [LexSenses!]!
}

"""
aggregate stddev on columns
"""
type LexSensesStddevFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate stddev_pop on columns
"""
type LexSensesStddev_popFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate stddev_samp on columns
"""
type LexSensesStddev_sampFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate sum on columns
"""
type LexSensesSumFields {
  classID: Int
  hvo: Int
  ownOrd: Int
  owningFlid: Int
}

"""
aggregate var_pop on columns
"""
type LexSensesVar_popFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate var_samp on columns
"""
type LexSensesVar_sampFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate variance on columns
"""
type LexSensesVarianceFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
columns and relationships of "MoForms"
"""
type MoForms {
  LexEntry_AlternateFormsGuid: uuid
  MoAffixForm_MsEnvPartOfSpeechGuid: uuid
  MoForm_MorphTypeGuid: uuid
  MoForm_StemNameGuid: uuid
  classID: Int!
  discriminator: String!
  form(
    """
    JSON select path
    """
    path: String
  ): jsonb
  guid: uuid!
  hvo: Int!
  isAbstract: Boolean!

  """
  An array relationship
  """
  lexEntrys(
    """
    distinct select on columns
    """
    distinctOn: [LexEntrysSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexEntrysOrderBy!]

    """
    filter the rows returned
    """
    where: LexEntrysBoolExp
  ): [LexEntrys!]!

  """
  An aggregate relationship
  """
  lexEntrysAggregate(
    """
    distinct select on columns
    """
    distinctOn: [LexEntrysSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [LexEntrysOrderBy!]

    """
    filter the rows returned
    """
    where: LexEntrysBoolExp
  ): LexEntrysAggregate!
  liftResidue: String

  """
  An object relationship
  """
  morphType: Possibilitys
  morphTypeGuid: uuid
  msEnvFeaturesGuid: uuid
  msEnvPartOfSpeechGuid: uuid
  ownOrd: Int!
  owner: uuid
  owningFlid: Int!

  """
  An object relationship
  """
  partOfSpeech: Possibilitys
  stemNameGuid: uuid
}

"""
aggregated selection of "MoForms"
"""
type MoFormsAggregate {
  aggregate: MoFormsAggregateFields
  nodes: [MoForms!]!
}

"""
aggregate fields of "MoForms"
"""
type MoFormsAggregateFields {
  avg: MoFormsAvgFields
  count(columns: [MoFormsSelectColumn!], distinct: Boolean): Int!
  max: MoFormsMaxFields
  min: MoFormsMinFields
  stddev: MoFormsStddevFields
  stddevPop: MoFormsStddev_popFields
  stddevSamp: MoFormsStddev_sampFields
  sum: MoFormsSumFields
  varPop: MoFormsVar_popFields
  varSamp: MoFormsVar_sampFields
  variance: MoFormsVarianceFields
}

"""
aggregate avg on columns
"""
type MoFormsAvgFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate max on columns
"""
type MoFormsMaxFields {
  LexEntry_AlternateFormsGuid: uuid
  MoAffixForm_MsEnvPartOfSpeechGuid: uuid
  MoForm_MorphTypeGuid: uuid
  MoForm_StemNameGuid: uuid
  classID: Int
  discriminator: String
  guid: uuid
  hvo: Int
  liftResidue: String
  morphTypeGuid: uuid
  msEnvFeaturesGuid: uuid
  msEnvPartOfSpeechGuid: uuid
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  stemNameGuid: uuid
}

"""
aggregate min on columns
"""
type MoFormsMinFields {
  LexEntry_AlternateFormsGuid: uuid
  MoAffixForm_MsEnvPartOfSpeechGuid: uuid
  MoForm_MorphTypeGuid: uuid
  MoForm_StemNameGuid: uuid
  classID: Int
  discriminator: String
  guid: uuid
  hvo: Int
  liftResidue: String
  morphTypeGuid: uuid
  msEnvFeaturesGuid: uuid
  msEnvPartOfSpeechGuid: uuid
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  stemNameGuid: uuid
}

"""
response of any mutation on the table "MoForms"
"""
type MoFormsMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [MoForms!]!
}

"""
aggregate stddev on columns
"""
type MoFormsStddevFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate stddev_pop on columns
"""
type MoFormsStddev_popFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate stddev_samp on columns
"""
type MoFormsStddev_sampFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate sum on columns
"""
type MoFormsSumFields {
  classID: Int
  hvo: Int
  ownOrd: Int
  owningFlid: Int
}

"""
aggregate var_pop on columns
"""
type MoFormsVar_popFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate var_samp on columns
"""
type MoFormsVar_sampFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate variance on columns
"""
type MoFormsVarianceFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
columns and relationships of "MoMorphSynAnalysiss"
"""
type MoMorphSynAnalysiss {
  LexEntry_MorphoSyntaxAnalysesGuid: uuid
  LfMoDerivAffMsa_MoMorphSynAnalysis_AffixCategoryGuid: uuid
  LfMoDerivStepMsa_MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  LfMoStemMsa_MoMorphSynAnalysis_InflectionClassGuid: uuid
  LfMoStemMsa_MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  LfMoStemMsa_MoMorphSynAnalysis_StratumGuid: uuid
  LfMoUnclassifiedAffixMsa_MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  MoMorphSynAnalysis_AffixCategoryGuid: uuid
  MoMorphSynAnalysis_FromInflectionClassGuid: uuid
  MoMorphSynAnalysis_FromPartOfSpeechGuid: uuid
  MoMorphSynAnalysis_FromStemNameGuid: uuid
  MoMorphSynAnalysis_InflectionClassGuid: uuid
  MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  MoMorphSynAnalysis_StratumGuid: uuid
  MoMorphSynAnalysis_ToInflectionClassGuid: uuid
  MoMorphSynAnalysis_ToPartOfSpeechGuid: uuid
  affixCategoryGuid: uuid
  classID: Int!
  discriminator: String!
  fromInflectionClassGuid: uuid
  fromMsFeaturesGuid: uuid

  """
  An object relationship
  """
  fromPartOfSpeech: Possibilitys
  fromPartOfSpeechGuid: uuid
  fromStemNameGuid: uuid
  glossString: String
  guid: uuid!
  hvo: Int!
  inflFeatsGuid: uuid
  inflectionClassGuid: uuid
  lfMoDerivAffMsaAffixCategoryGuid: uuid
  lfMoDerivStepMsaInflFeatsGuid: uuid
  lfMoDerivStepMsaPartOfSpeechGuid: uuid
  lfMoStemMsaInflectionClassGuid: uuid
  lfMoStemMsaMsFeaturesGuid: uuid
  lfMoStemMsaPartOfSpeechGuid: uuid
  lfMoStemMsaStratumGuid: uuid
  lfMoUnclassifiedAffixMsaPartOfSpeechGuid: uuid
  liftResidue: String
  msFeaturesGuid: uuid
  ownOrd: Int!
  owner: uuid
  owningFlid: Int!

  """
  An object relationship
  """
  partOfSpeech: Possibilitys
  partOfSpeechGuid: uuid
  stratumGuid: uuid
  toInflectionClassGuid: uuid
  toMsFeaturesGuid: uuid

  """
  An object relationship
  """
  toPartOfSpeech: Possibilitys
  toPartOfSpeechGuid: uuid
}

"""
aggregated selection of "MoMorphSynAnalysiss"
"""
type MoMorphSynAnalysissAggregate {
  aggregate: MoMorphSynAnalysissAggregateFields
  nodes: [MoMorphSynAnalysiss!]!
}

"""
aggregate fields of "MoMorphSynAnalysiss"
"""
type MoMorphSynAnalysissAggregateFields {
  avg: MoMorphSynAnalysissAvgFields
  count(columns: [MoMorphSynAnalysissSelectColumn!], distinct: Boolean): Int!
  max: MoMorphSynAnalysissMaxFields
  min: MoMorphSynAnalysissMinFields
  stddev: MoMorphSynAnalysissStddevFields
  stddevPop: MoMorphSynAnalysissStddev_popFields
  stddevSamp: MoMorphSynAnalysissStddev_sampFields
  sum: MoMorphSynAnalysissSumFields
  varPop: MoMorphSynAnalysissVar_popFields
  varSamp: MoMorphSynAnalysissVar_sampFields
  variance: MoMorphSynAnalysissVarianceFields
}

"""
aggregate avg on columns
"""
type MoMorphSynAnalysissAvgFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate max on columns
"""
type MoMorphSynAnalysissMaxFields {
  LexEntry_MorphoSyntaxAnalysesGuid: uuid
  LfMoDerivAffMsa_MoMorphSynAnalysis_AffixCategoryGuid: uuid
  LfMoDerivStepMsa_MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  LfMoStemMsa_MoMorphSynAnalysis_InflectionClassGuid: uuid
  LfMoStemMsa_MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  LfMoStemMsa_MoMorphSynAnalysis_StratumGuid: uuid
  LfMoUnclassifiedAffixMsa_MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  MoMorphSynAnalysis_AffixCategoryGuid: uuid
  MoMorphSynAnalysis_FromInflectionClassGuid: uuid
  MoMorphSynAnalysis_FromPartOfSpeechGuid: uuid
  MoMorphSynAnalysis_FromStemNameGuid: uuid
  MoMorphSynAnalysis_InflectionClassGuid: uuid
  MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  MoMorphSynAnalysis_StratumGuid: uuid
  MoMorphSynAnalysis_ToInflectionClassGuid: uuid
  MoMorphSynAnalysis_ToPartOfSpeechGuid: uuid
  affixCategoryGuid: uuid
  classID: Int
  discriminator: String
  fromInflectionClassGuid: uuid
  fromMsFeaturesGuid: uuid
  fromPartOfSpeechGuid: uuid
  fromStemNameGuid: uuid
  glossString: String
  guid: uuid
  hvo: Int
  inflFeatsGuid: uuid
  inflectionClassGuid: uuid
  lfMoDerivAffMsaAffixCategoryGuid: uuid
  lfMoDerivStepMsaInflFeatsGuid: uuid
  lfMoDerivStepMsaPartOfSpeechGuid: uuid
  lfMoStemMsaInflectionClassGuid: uuid
  lfMoStemMsaMsFeaturesGuid: uuid
  lfMoStemMsaPartOfSpeechGuid: uuid
  lfMoStemMsaStratumGuid: uuid
  lfMoUnclassifiedAffixMsaPartOfSpeechGuid: uuid
  liftResidue: String
  msFeaturesGuid: uuid
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  partOfSpeechGuid: uuid
  stratumGuid: uuid
  toInflectionClassGuid: uuid
  toMsFeaturesGuid: uuid
  toPartOfSpeechGuid: uuid
}

"""
aggregate min on columns
"""
type MoMorphSynAnalysissMinFields {
  LexEntry_MorphoSyntaxAnalysesGuid: uuid
  LfMoDerivAffMsa_MoMorphSynAnalysis_AffixCategoryGuid: uuid
  LfMoDerivStepMsa_MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  LfMoStemMsa_MoMorphSynAnalysis_InflectionClassGuid: uuid
  LfMoStemMsa_MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  LfMoStemMsa_MoMorphSynAnalysis_StratumGuid: uuid
  LfMoUnclassifiedAffixMsa_MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  MoMorphSynAnalysis_AffixCategoryGuid: uuid
  MoMorphSynAnalysis_FromInflectionClassGuid: uuid
  MoMorphSynAnalysis_FromPartOfSpeechGuid: uuid
  MoMorphSynAnalysis_FromStemNameGuid: uuid
  MoMorphSynAnalysis_InflectionClassGuid: uuid
  MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  MoMorphSynAnalysis_StratumGuid: uuid
  MoMorphSynAnalysis_ToInflectionClassGuid: uuid
  MoMorphSynAnalysis_ToPartOfSpeechGuid: uuid
  affixCategoryGuid: uuid
  classID: Int
  discriminator: String
  fromInflectionClassGuid: uuid
  fromMsFeaturesGuid: uuid
  fromPartOfSpeechGuid: uuid
  fromStemNameGuid: uuid
  glossString: String
  guid: uuid
  hvo: Int
  inflFeatsGuid: uuid
  inflectionClassGuid: uuid
  lfMoDerivAffMsaAffixCategoryGuid: uuid
  lfMoDerivStepMsaInflFeatsGuid: uuid
  lfMoDerivStepMsaPartOfSpeechGuid: uuid
  lfMoStemMsaInflectionClassGuid: uuid
  lfMoStemMsaMsFeaturesGuid: uuid
  lfMoStemMsaPartOfSpeechGuid: uuid
  lfMoStemMsaStratumGuid: uuid
  lfMoUnclassifiedAffixMsaPartOfSpeechGuid: uuid
  liftResidue: String
  msFeaturesGuid: uuid
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  partOfSpeechGuid: uuid
  stratumGuid: uuid
  toInflectionClassGuid: uuid
  toMsFeaturesGuid: uuid
  toPartOfSpeechGuid: uuid
}

"""
response of any mutation on the table "MoMorphSynAnalysiss"
"""
type MoMorphSynAnalysissMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [MoMorphSynAnalysiss!]!
}

"""
aggregate stddev on columns
"""
type MoMorphSynAnalysissStddevFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate stddev_pop on columns
"""
type MoMorphSynAnalysissStddev_popFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate stddev_samp on columns
"""
type MoMorphSynAnalysissStddev_sampFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate sum on columns
"""
type MoMorphSynAnalysissSumFields {
  classID: Int
  hvo: Int
  ownOrd: Int
  owningFlid: Int
}

"""
aggregate var_pop on columns
"""
type MoMorphSynAnalysissVar_popFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate var_samp on columns
"""
type MoMorphSynAnalysissVar_sampFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate variance on columns
"""
type MoMorphSynAnalysissVarianceFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
columns and relationships of "Notes"
"""
type Notes {
  Segment_NotesGuid: uuid
  classID: Int!
  content(
    """
    JSON select path
    """
    path: String
  ): jsonb
  guid: uuid!
  hvo: Int!
  ownOrd: Int!
  owner: uuid
  owningFlid: Int!
}

"""
aggregated selection of "Notes"
"""
type NotesAggregate {
  aggregate: NotesAggregateFields
  nodes: [Notes!]!
}

"""
aggregate fields of "Notes"
"""
type NotesAggregateFields {
  avg: NotesAvgFields
  count(columns: [NotesSelectColumn!], distinct: Boolean): Int!
  max: NotesMaxFields
  min: NotesMinFields
  stddev: NotesStddevFields
  stddevPop: NotesStddev_popFields
  stddevSamp: NotesStddev_sampFields
  sum: NotesSumFields
  varPop: NotesVar_popFields
  varSamp: NotesVar_sampFields
  variance: NotesVarianceFields
}

"""
aggregate avg on columns
"""
type NotesAvgFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate max on columns
"""
type NotesMaxFields {
  Segment_NotesGuid: uuid
  classID: Int
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
}

"""
aggregate min on columns
"""
type NotesMinFields {
  Segment_NotesGuid: uuid
  classID: Int
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
}

"""
response of any mutation on the table "Notes"
"""
type NotesMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Notes!]!
}

"""
aggregate stddev on columns
"""
type NotesStddevFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate stddev_pop on columns
"""
type NotesStddev_popFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate stddev_samp on columns
"""
type NotesStddev_sampFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate sum on columns
"""
type NotesSumFields {
  classID: Int
  hvo: Int
  ownOrd: Int
  owningFlid: Int
}

"""
aggregate var_pop on columns
"""
type NotesVar_popFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate var_samp on columns
"""
type NotesVar_sampFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate variance on columns
"""
type NotesVarianceFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
columns and relationships of "Possibilitys"
"""
type Possibilitys {
  MajorObject_PossibilitiesGuid: uuid
  Possibility_ConfidenceGuid: uuid
  Possibility_DefaultInflectionClassGuid: uuid
  Possibility_EducationGuid: uuid
  Possibility_PlaceOfBirthGuid: uuid
  Possibility_StatusGuid: uuid
  Possibility_SubPossibilitiesGuid: uuid
  abbreviation(
    """
    JSON select path
    """
    path: String
  ): jsonb
  alias(
    """
    JSON select path
    """
    path: String
  ): jsonb
  allowsComment: Boolean
  allowsFeatureStructure: Boolean
  allowsInstanceOf: Boolean
  backColor: Int!
  canCreateOrphan: Boolean
  catalogSourceId: String
  classID: Int!
  confidenceGuid: uuid
  copyCutPastable: Boolean
  dateCreated: timestamptz!
  dateModified: timestamptz!
  dateOfBirth(
    """
    JSON select path
    """
    path: String
  ): jsonb
  dateOfDeath(
    """
    JSON select path
    """
    path: String
  ): jsonb
  defaultFeaturesGuid: uuid
  defaultInflectionClassGuid: uuid
  description(
    """
    JSON select path
    """
    path: String
  ): jsonb
  discriminator: String!
  discussionGuid: uuid
  educationGuid: uuid
  foreColor: Int!
  gender: Int
  glossAppend(
    """
    JSON select path
    """
    path: String
  ): jsonb
  glossPrepend(
    """
    JSON select path
    """
    path: String
  ): jsonb
  guid: uuid!
  helpId: String
  hidden: Boolean!
  hvo: Int!
  inflFeatsGuid: uuid
  inherFeatValGuid: uuid
  instanceOfSignature: Int
  isProtected: Boolean!
  isResearcher: Boolean
  lfLexEntryTypeReverseName(
    """
    JSON select path
    """
    path: String
  ): jsonb
  lfLocationAlias(
    """
    JSON select path
    """
    path: String
  ): jsonb
  louwNidaCodes: String
  mappingType: Int
  maxDupOccur: Int
  multi: Boolean
  name(
    """
    JSON select path
    """
    path: String
  ): jsonb
  ocmCodes: String
  ownOrd: Int!
  owner: uuid
  owningFlid: Int!
  placeOfBirthGuid: uuid
  postfix: String
  prefix: String
  promptUser: Boolean
  reverseAbbr(
    """
    JSON select path
    """
    path: String
  ): jsonb
  reverseAbbreviation(
    """
    JSON select path
    """
    path: String
  ): jsonb
  reverseName(
    """
    JSON select path
    """
    path: String
  ): jsonb
  secondaryOrder: Int
  seeAlso(
    """
    JSON select path
    """
    path: String
  ): jsonb
  severity: Int
  sortSpec: Int!
  statusGuid: uuid
  termId: Int
  underColor: Int!
  underStyle: Int!
  userCanCreate: Boolean
  zeroWidth: Boolean
}

"""
aggregated selection of "Possibilitys"
"""
type PossibilitysAggregate {
  aggregate: PossibilitysAggregateFields
  nodes: [Possibilitys!]!
}

"""
aggregate fields of "Possibilitys"
"""
type PossibilitysAggregateFields {
  avg: PossibilitysAvgFields
  count(columns: [PossibilitysSelectColumn!], distinct: Boolean): Int!
  max: PossibilitysMaxFields
  min: PossibilitysMinFields
  stddev: PossibilitysStddevFields
  stddevPop: PossibilitysStddev_popFields
  stddevSamp: PossibilitysStddev_sampFields
  sum: PossibilitysSumFields
  varPop: PossibilitysVar_popFields
  varSamp: PossibilitysVar_sampFields
  variance: PossibilitysVarianceFields
}

"""
aggregate avg on columns
"""
type PossibilitysAvgFields {
  backColor: Float
  classID: Float
  foreColor: Float
  gender: Float
  hvo: Float
  instanceOfSignature: Float
  mappingType: Float
  maxDupOccur: Float
  ownOrd: Float
  owningFlid: Float
  secondaryOrder: Float
  severity: Float
  sortSpec: Float
  termId: Float
  underColor: Float
  underStyle: Float
}

"""
aggregate max on columns
"""
type PossibilitysMaxFields {
  MajorObject_PossibilitiesGuid: uuid
  Possibility_ConfidenceGuid: uuid
  Possibility_DefaultInflectionClassGuid: uuid
  Possibility_EducationGuid: uuid
  Possibility_PlaceOfBirthGuid: uuid
  Possibility_StatusGuid: uuid
  Possibility_SubPossibilitiesGuid: uuid
  backColor: Int
  catalogSourceId: String
  classID: Int
  confidenceGuid: uuid
  dateCreated: timestamptz
  dateModified: timestamptz
  defaultFeaturesGuid: uuid
  defaultInflectionClassGuid: uuid
  discriminator: String
  discussionGuid: uuid
  educationGuid: uuid
  foreColor: Int
  gender: Int
  guid: uuid
  helpId: String
  hvo: Int
  inflFeatsGuid: uuid
  inherFeatValGuid: uuid
  instanceOfSignature: Int
  louwNidaCodes: String
  mappingType: Int
  maxDupOccur: Int
  ocmCodes: String
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  placeOfBirthGuid: uuid
  postfix: String
  prefix: String
  secondaryOrder: Int
  severity: Int
  sortSpec: Int
  statusGuid: uuid
  termId: Int
  underColor: Int
  underStyle: Int
}

"""
aggregate min on columns
"""
type PossibilitysMinFields {
  MajorObject_PossibilitiesGuid: uuid
  Possibility_ConfidenceGuid: uuid
  Possibility_DefaultInflectionClassGuid: uuid
  Possibility_EducationGuid: uuid
  Possibility_PlaceOfBirthGuid: uuid
  Possibility_StatusGuid: uuid
  Possibility_SubPossibilitiesGuid: uuid
  backColor: Int
  catalogSourceId: String
  classID: Int
  confidenceGuid: uuid
  dateCreated: timestamptz
  dateModified: timestamptz
  defaultFeaturesGuid: uuid
  defaultInflectionClassGuid: uuid
  discriminator: String
  discussionGuid: uuid
  educationGuid: uuid
  foreColor: Int
  gender: Int
  guid: uuid
  helpId: String
  hvo: Int
  inflFeatsGuid: uuid
  inherFeatValGuid: uuid
  instanceOfSignature: Int
  louwNidaCodes: String
  mappingType: Int
  maxDupOccur: Int
  ocmCodes: String
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  placeOfBirthGuid: uuid
  postfix: String
  prefix: String
  secondaryOrder: Int
  severity: Int
  sortSpec: Int
  statusGuid: uuid
  termId: Int
  underColor: Int
  underStyle: Int
}

"""
response of any mutation on the table "Possibilitys"
"""
type PossibilitysMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Possibilitys!]!
}

"""
aggregate stddev on columns
"""
type PossibilitysStddevFields {
  backColor: Float
  classID: Float
  foreColor: Float
  gender: Float
  hvo: Float
  instanceOfSignature: Float
  mappingType: Float
  maxDupOccur: Float
  ownOrd: Float
  owningFlid: Float
  secondaryOrder: Float
  severity: Float
  sortSpec: Float
  termId: Float
  underColor: Float
  underStyle: Float
}

"""
aggregate stddev_pop on columns
"""
type PossibilitysStddev_popFields {
  backColor: Float
  classID: Float
  foreColor: Float
  gender: Float
  hvo: Float
  instanceOfSignature: Float
  mappingType: Float
  maxDupOccur: Float
  ownOrd: Float
  owningFlid: Float
  secondaryOrder: Float
  severity: Float
  sortSpec: Float
  termId: Float
  underColor: Float
  underStyle: Float
}

"""
aggregate stddev_samp on columns
"""
type PossibilitysStddev_sampFields {
  backColor: Float
  classID: Float
  foreColor: Float
  gender: Float
  hvo: Float
  instanceOfSignature: Float
  mappingType: Float
  maxDupOccur: Float
  ownOrd: Float
  owningFlid: Float
  secondaryOrder: Float
  severity: Float
  sortSpec: Float
  termId: Float
  underColor: Float
  underStyle: Float
}

"""
aggregate sum on columns
"""
type PossibilitysSumFields {
  backColor: Int
  classID: Int
  foreColor: Int
  gender: Int
  hvo: Int
  instanceOfSignature: Int
  mappingType: Int
  maxDupOccur: Int
  ownOrd: Int
  owningFlid: Int
  secondaryOrder: Int
  severity: Int
  sortSpec: Int
  termId: Int
  underColor: Int
  underStyle: Int
}

"""
aggregate var_pop on columns
"""
type PossibilitysVar_popFields {
  backColor: Float
  classID: Float
  foreColor: Float
  gender: Float
  hvo: Float
  instanceOfSignature: Float
  mappingType: Float
  maxDupOccur: Float
  ownOrd: Float
  owningFlid: Float
  secondaryOrder: Float
  severity: Float
  sortSpec: Float
  termId: Float
  underColor: Float
  underStyle: Float
}

"""
aggregate var_samp on columns
"""
type PossibilitysVar_sampFields {
  backColor: Float
  classID: Float
  foreColor: Float
  gender: Float
  hvo: Float
  instanceOfSignature: Float
  mappingType: Float
  maxDupOccur: Float
  ownOrd: Float
  owningFlid: Float
  secondaryOrder: Float
  severity: Float
  sortSpec: Float
  termId: Float
  underColor: Float
  underStyle: Float
}

"""
aggregate variance on columns
"""
type PossibilitysVarianceFields {
  backColor: Float
  classID: Float
  foreColor: Float
  gender: Float
  hvo: Float
  instanceOfSignature: Float
  mappingType: Float
  maxDupOccur: Float
  ownOrd: Float
  owningFlid: Float
  secondaryOrder: Float
  severity: Float
  sortSpec: Float
  termId: Float
  underColor: Float
  underStyle: Float
}

"""
columns and relationships of "ProjectUsers"
"""
type ProjectUsers {
  """
  An object relationship
  """
  Projects: Projects!

  """
  An object relationship
  """
  User: Users!
  createdDate: timestamptz!
  id: uuid!
  projectId: uuid!
  role: Int!
  updatedDate: timestamptz!
  userId: uuid!
}

type LexBox_ProjectUsers {
  userId: UUID!
  projectId: UUID!
  role: ProjectRole!
  user: User!
  project: Project!
  id: UUID!
  createdDate: DateTime!
  updatedDate: DateTime!
}

"""
aggregated selection of "ProjectUsers"
"""
type ProjectUsersAggregate {
  aggregate: ProjectUsersAggregateFields
  nodes: [ProjectUsers!]!
}

"""
aggregate fields of "ProjectUsers"
"""
type ProjectUsersAggregateFields {
  avg: ProjectUsersAvgFields
  count(columns: [ProjectUsersSelectColumn!], distinct: Boolean): Int!
  max: ProjectUsersMaxFields
  min: ProjectUsersMinFields
  stddev: ProjectUsersStddevFields
  stddevPop: ProjectUsersStddev_popFields
  stddevSamp: ProjectUsersStddev_sampFields
  sum: ProjectUsersSumFields
  varPop: ProjectUsersVar_popFields
  varSamp: ProjectUsersVar_sampFields
  variance: ProjectUsersVarianceFields
}

"""
aggregate avg on columns
"""
type ProjectUsersAvgFields {
  role: Float
}

"""
aggregate max on columns
"""
type ProjectUsersMaxFields {
  createdDate: timestamptz
  id: uuid
  projectId: uuid
  role: Int
  updatedDate: timestamptz
  userId: uuid
}

"""
aggregate min on columns
"""
type ProjectUsersMinFields {
  createdDate: timestamptz
  id: uuid
  projectId: uuid
  role: Int
  updatedDate: timestamptz
  userId: uuid
}

"""
response of any mutation on the table "ProjectUsers"
"""
type ProjectUsersMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [ProjectUsers!]!
}

"""
aggregate stddev on columns
"""
type ProjectUsersStddevFields {
  role: Float
}

"""
aggregate stddev_pop on columns
"""
type ProjectUsersStddev_popFields {
  role: Float
}

"""
aggregate stddev_samp on columns
"""
type ProjectUsersStddev_sampFields {
  role: Float
}

"""
aggregate sum on columns
"""
type ProjectUsersSumFields {
  role: Int
}

"""
aggregate var_pop on columns
"""
type ProjectUsersVar_popFields {
  role: Float
}

"""
aggregate var_samp on columns
"""
type ProjectUsersVar_sampFields {
  role: Float
}

"""
aggregate variance on columns
"""
type ProjectUsersVarianceFields {
  role: Float
}

"""
columns and relationships of "Projects"
"""
type Projects {
  """
  An array relationship
  """
  ProjectUsers(
    """
    distinct select on columns
    """
    distinctOn: [ProjectUsersSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ProjectUsersOrderBy!]

    """
    filter the rows returned
    """
    where: ProjectUsersBoolExp
  ): [ProjectUsers!]!
  code: String!
  createdDate: timestamptz!
  description: String
  id: uuid!
  name: String!

  """
  An aggregate relationship
  """
  projectUsersAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ProjectUsersSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ProjectUsersOrderBy!]

    """
    filter the rows returned
    """
    where: ProjectUsersBoolExp
  ): ProjectUsersAggregate!
  retentionPolicy: Int!
  type: Int!
  updatedDate: timestamptz!
}

"""
aggregated selection of "Projects"
"""
type ProjectsAggregate {
  aggregate: ProjectsAggregateFields
  nodes: [Projects!]!
}

"""
aggregate fields of "Projects"
"""
type ProjectsAggregateFields {
  avg: ProjectsAvgFields
  count(columns: [ProjectsSelectColumn!], distinct: Boolean): Int!
  max: ProjectsMaxFields
  min: ProjectsMinFields
  stddev: ProjectsStddevFields
  stddevPop: ProjectsStddev_popFields
  stddevSamp: ProjectsStddev_sampFields
  sum: ProjectsSumFields
  varPop: ProjectsVar_popFields
  varSamp: ProjectsVar_sampFields
  variance: ProjectsVarianceFields
}

"""
aggregate avg on columns
"""
type ProjectsAvgFields {
  retentionPolicy: Float
  type: Float
}

"""
aggregate max on columns
"""
type ProjectsMaxFields {
  code: String
  createdDate: timestamptz
  description: String
  id: uuid
  name: String
  retentionPolicy: Int
  type: Int
  updatedDate: timestamptz
}

"""
aggregate min on columns
"""
type ProjectsMinFields {
  code: String
  createdDate: timestamptz
  description: String
  id: uuid
  name: String
  retentionPolicy: Int
  type: Int
  updatedDate: timestamptz
}

"""
response of any mutation on the table "Projects"
"""
type ProjectsMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Projects!]!
}

"""
aggregate stddev on columns
"""
type ProjectsStddevFields {
  retentionPolicy: Float
  type: Float
}

"""
aggregate stddev_pop on columns
"""
type ProjectsStddev_popFields {
  retentionPolicy: Float
  type: Float
}

"""
aggregate stddev_samp on columns
"""
type ProjectsStddev_sampFields {
  retentionPolicy: Float
  type: Float
}

"""
aggregate sum on columns
"""
type ProjectsSumFields {
  retentionPolicy: Int
  type: Int
}

"""
aggregate var_pop on columns
"""
type ProjectsVar_popFields {
  retentionPolicy: Float
  type: Float
}

"""
aggregate var_samp on columns
"""
type ProjectsVar_sampFields {
  retentionPolicy: Float
  type: Float
}

"""
aggregate variance on columns
"""
type ProjectsVarianceFields {
  retentionPolicy: Float
  type: Float
}

"""
columns and relationships of "Translations"
"""
type Translations {
  LexExampleSentence_TranslationsGuid: uuid
  StPara_TranslationsGuid: uuid
  Translation_TypeGuid: uuid
  classID: Int!
  guid: uuid!
  hvo: Int!
  ownOrd: Int!
  owner: uuid
  owningFlid: Int!
  status(
    """
    JSON select path
    """
    path: String
  ): jsonb
  translation(
    """
    JSON select path
    """
    path: String
  ): jsonb
  typeGuid: uuid
}

"""
aggregated selection of "Translations"
"""
type TranslationsAggregate {
  aggregate: TranslationsAggregateFields
  nodes: [Translations!]!
}

"""
aggregate fields of "Translations"
"""
type TranslationsAggregateFields {
  avg: TranslationsAvgFields
  count(columns: [TranslationsSelectColumn!], distinct: Boolean): Int!
  max: TranslationsMaxFields
  min: TranslationsMinFields
  stddev: TranslationsStddevFields
  stddevPop: TranslationsStddev_popFields
  stddevSamp: TranslationsStddev_sampFields
  sum: TranslationsSumFields
  varPop: TranslationsVar_popFields
  varSamp: TranslationsVar_sampFields
  variance: TranslationsVarianceFields
}

"""
aggregate avg on columns
"""
type TranslationsAvgFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate max on columns
"""
type TranslationsMaxFields {
  LexExampleSentence_TranslationsGuid: uuid
  StPara_TranslationsGuid: uuid
  Translation_TypeGuid: uuid
  classID: Int
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  typeGuid: uuid
}

"""
aggregate min on columns
"""
type TranslationsMinFields {
  LexExampleSentence_TranslationsGuid: uuid
  StPara_TranslationsGuid: uuid
  Translation_TypeGuid: uuid
  classID: Int
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  typeGuid: uuid
}

"""
response of any mutation on the table "Translations"
"""
type TranslationsMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Translations!]!
}

"""
aggregate stddev on columns
"""
type TranslationsStddevFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate stddev_pop on columns
"""
type TranslationsStddev_popFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate stddev_samp on columns
"""
type TranslationsStddev_sampFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate sum on columns
"""
type TranslationsSumFields {
  classID: Int
  hvo: Int
  ownOrd: Int
  owningFlid: Int
}

"""
aggregate var_pop on columns
"""
type TranslationsVar_popFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate var_samp on columns
"""
type TranslationsVar_sampFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
aggregate variance on columns
"""
type TranslationsVarianceFields {
  classID: Float
  hvo: Float
  ownOrd: Float
  owningFlid: Float
}

"""
columns and relationships of "Users"
"""
type Users {
  """
  An array relationship
  """
  UserProjects(
    """
    distinct select on columns
    """
    distinctOn: [ProjectUsersSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ProjectUsersOrderBy!]

    """
    filter the rows returned
    """
    where: ProjectUsersBoolExp
  ): [ProjectUsers!]!
  createdDate: timestamptz!
  email: String!
  id: uuid!
  isAdmin: Boolean!
  name: String!
  passwordHash: String!
  salt: String!
  updatedDate: timestamptz!

  """
  An aggregate relationship
  """
  userProjectsAggregate(
    """
    distinct select on columns
    """
    distinctOn: [ProjectUsersSelectColumn!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    orderBy: [ProjectUsersOrderBy!]

    """
    filter the rows returned
    """
    where: ProjectUsersBoolExp
  ): ProjectUsersAggregate!
  username: String
}

"""
aggregated selection of "Users"
"""
type UsersAggregate {
  aggregate: UsersAggregateFields
  nodes: [Users!]!
}

"""
aggregate fields of "Users"
"""
type UsersAggregateFields {
  count(columns: [UsersSelectColumn!], distinct: Boolean): Int!
  max: UsersMaxFields
  min: UsersMinFields
}

"""
aggregate max on columns
"""
type UsersMaxFields {
  createdDate: timestamptz
  email: String
  id: uuid
  name: String
  passwordHash: String
  salt: String
  updatedDate: timestamptz
  username: String
}

"""
aggregate min on columns
"""
type UsersMinFields {
  createdDate: timestamptz
  email: String
  id: uuid
  name: String
  passwordHash: String
  salt: String
  updatedDate: timestamptz
  username: String
}

"""
response of any mutation on the table "Users"
"""
type UsersMutationResponse {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Users!]!
}

"""
Boolean expression to filter rows from the table "AgentEvaluations". All fields are combined with a logical 'AND'.
"""
input AgentEvaluationsBoolExp {
  _and: [AgentEvaluationsBoolExp!]
  _not: AgentEvaluationsBoolExp
  _or: [AgentEvaluationsBoolExp!]
  classID: IntComparisonExp
  guid: UuidComparisonExp
  hvo: IntComparisonExp
  ownOrd: IntComparisonExp
  owner: UuidComparisonExp
  owningFlid: IntComparisonExp
}

"""
input type for incrementing numeric columns in table "AgentEvaluations"
"""
input AgentEvaluationsIncInput {
  classID: Int
  hvo: Int
  ownOrd: Int
  owningFlid: Int
}

"""
input type for inserting data into table "AgentEvaluations"
"""
input AgentEvaluationsInsertInput {
  classID: Int
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
}

"""
on_conflict condition type for table "AgentEvaluations"
"""
input AgentEvaluationsOnConflict {
  constraint: AgentEvaluationsConstraint!
  update_columns: [AgentEvaluationsUpdateColumn!]! = []
  where: AgentEvaluationsBoolExp
}

"""
Ordering options when selecting data from "AgentEvaluations".
"""
input AgentEvaluationsOrderBy {
  classID: OrderBy
  guid: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
}

"""
primary key columns input for table: AgentEvaluations
"""
input AgentEvaluationsPkColumnsInput {
  guid: uuid!
}

"""
input type for updating data in table "AgentEvaluations"
"""
input AgentEvaluationsSetInput {
  classID: Int
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
}

"""
Streaming cursor of the table "AgentEvaluations"
"""
input AgentEvaluationsStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: AgentEvaluationsStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input AgentEvaluationsStreamCursorValueInput {
  classID: Int
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
}

input AgentEvaluationsUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: AgentEvaluationsIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: AgentEvaluationsSetInput

  """
  filter the rows which have to be updated
  """
  where: AgentEvaluationsBoolExp!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input JsonbCastExp {
  String: StringComparisonExp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input JsonbComparisonExp {
  _cast: JsonbCastExp

  """
  is the column contained in the given json value
  """
  _containedIn: jsonb

  """
  does the column contain the given json value at the top level
  """
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """
  does the string exist as a top-level key in the column
  """
  _hasKey: String

  """
  do all of these strings exist as top-level keys in the column
  """
  _hasKeysAll: [String!]

  """
  do any of these strings exist as top-level keys in the column
  """
  _hasKeysAny: [String!]
  _in: [jsonb!]
  _isNull: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
order by aggregate values of table "LexEntrys"
"""
input LexEntrysAggregateOrderBy {
  avg: LexEntrys_avg_order_by
  count: OrderBy
  max: LexEntrys_max_order_by
  min: LexEntrys_min_order_by
  stddev: LexEntrys_stddev_order_by
  stddev_pop: LexEntrys_stddev_pop_order_by
  stddev_samp: LexEntrys_stddev_samp_order_by
  sum: LexEntrys_sum_order_by
  var_pop: LexEntrys_var_pop_order_by
  var_samp: LexEntrys_var_samp_order_by
  variance: LexEntrys_variance_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input LexEntrysAppendInput {
  bibliography: jsonb
  citationForm: jsonb
  comment: jsonb
  literalMeaning: jsonb
  restrictions: jsonb
  summaryDefinition: jsonb
}

"""
input type for inserting array relation for remote table "LexEntrys"
"""
input LexEntrysArrRelInsertInput {
  data: [LexEntrysInsertInput!]!

  """
  upsert condition
  """
  onConflict: LexEntrysOnConflict
}

"""
Boolean expression to filter rows from the table "LexEntrys". All fields are combined with a logical 'AND'.
"""
input LexEntrysBoolExp {
  _and: [LexEntrysBoolExp!]
  _not: LexEntrysBoolExp
  _or: [LexEntrysBoolExp!]
  bibliography: JsonbComparisonExp
  citationForm: JsonbComparisonExp
  classID: IntComparisonExp
  comment: JsonbComparisonExp
  dateCreated: TimestamptzComparisonExp
  dateModified: TimestamptzComparisonExp
  doNotUseForParsing: BooleanComparisonExp
  guid: UuidComparisonExp
  homographNumber: IntComparisonExp
  hvo: IntComparisonExp
  importResidue: StringComparisonExp
  lexSenses: LexSensesBoolExp
  lexSenses_aggregate: LexSenses_aggregate_bool_exp
  lexemeFormGuid: UuidComparisonExp
  liftResidue: StringComparisonExp
  literalMeaning: JsonbComparisonExp
  moForm: MoFormsBoolExp
  ownOrd: IntComparisonExp
  owner: UuidComparisonExp
  owningFlid: IntComparisonExp
  restrictions: JsonbComparisonExp
  summaryDefinition: JsonbComparisonExp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input LexEntrysDeleteAtPathInput {
  bibliography: [String!]
  citationForm: [String!]
  comment: [String!]
  literalMeaning: [String!]
  restrictions: [String!]
  summaryDefinition: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input LexEntrysDeleteElemInput {
  bibliography: Int
  citationForm: Int
  comment: Int
  literalMeaning: Int
  restrictions: Int
  summaryDefinition: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input LexEntrysDeleteKeyInput {
  bibliography: String
  citationForm: String
  comment: String
  literalMeaning: String
  restrictions: String
  summaryDefinition: String
}

"""
input type for incrementing numeric columns in table "LexEntrys"
"""
input LexEntrysIncInput {
  classID: Int
  homographNumber: Int
  hvo: Int
  ownOrd: Int
  owningFlid: Int
}

"""
input type for inserting data into table "LexEntrys"
"""
input LexEntrysInsertInput {
  bibliography: jsonb
  citationForm: jsonb
  classID: Int
  comment: jsonb
  dateCreated: timestamptz
  dateModified: timestamptz
  doNotUseForParsing: Boolean
  guid: uuid
  homographNumber: Int
  hvo: Int
  importResidue: String
  lexSenses: LexSensesArrRelInsertInput
  lexemeFormGuid: uuid
  liftResidue: String
  literalMeaning: jsonb
  moForm: MoFormsObjRelInsertInput
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  restrictions: jsonb
  summaryDefinition: jsonb
}

"""
input type for inserting object relation for remote table "LexEntrys"
"""
input LexEntrysObjRelInsertInput {
  data: LexEntrysInsertInput!

  """
  upsert condition
  """
  onConflict: LexEntrysOnConflict
}

"""
on_conflict condition type for table "LexEntrys"
"""
input LexEntrysOnConflict {
  constraint: LexEntrysConstraint!
  update_columns: [LexEntrysUpdateColumn!]! = []
  where: LexEntrysBoolExp
}

"""
Ordering options when selecting data from "LexEntrys".
"""
input LexEntrysOrderBy {
  bibliography: OrderBy
  citationForm: OrderBy
  classID: OrderBy
  comment: OrderBy
  dateCreated: OrderBy
  dateModified: OrderBy
  doNotUseForParsing: OrderBy
  guid: OrderBy
  homographNumber: OrderBy
  hvo: OrderBy
  importResidue: OrderBy
  lexSensesAggregate: LexSensesAggregateOrderBy
  lexemeFormGuid: OrderBy
  liftResidue: OrderBy
  literalMeaning: OrderBy
  moForm: MoFormsOrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
  restrictions: OrderBy
  summaryDefinition: OrderBy
}

"""
primary key columns input for table: LexEntrys
"""
input LexEntrysPkColumnsInput {
  guid: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input LexEntrysPrependInput {
  bibliography: jsonb
  citationForm: jsonb
  comment: jsonb
  literalMeaning: jsonb
  restrictions: jsonb
  summaryDefinition: jsonb
}

"""
input type for updating data in table "LexEntrys"
"""
input LexEntrysSetInput {
  bibliography: jsonb
  citationForm: jsonb
  classID: Int
  comment: jsonb
  dateCreated: timestamptz
  dateModified: timestamptz
  doNotUseForParsing: Boolean
  guid: uuid
  homographNumber: Int
  hvo: Int
  importResidue: String
  lexemeFormGuid: uuid
  liftResidue: String
  literalMeaning: jsonb
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  restrictions: jsonb
  summaryDefinition: jsonb
}

"""
Streaming cursor of the table "LexEntrys"
"""
input LexEntrysStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: LexEntrysStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input LexEntrysStreamCursorValueInput {
  bibliography: jsonb
  citationForm: jsonb
  classID: Int
  comment: jsonb
  dateCreated: timestamptz
  dateModified: timestamptz
  doNotUseForParsing: Boolean
  guid: uuid
  homographNumber: Int
  hvo: Int
  importResidue: String
  lexemeFormGuid: uuid
  liftResidue: String
  literalMeaning: jsonb
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  restrictions: jsonb
  summaryDefinition: jsonb
}

input LexEntrysUpdates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: LexEntrysAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: LexEntrysDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: LexEntrysDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: LexEntrysDeleteKeyInput

  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: LexEntrysIncInput

  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: LexEntrysPrependInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: LexEntrysSetInput

  """
  filter the rows which have to be updated
  """
  where: LexEntrysBoolExp!
}

input LexEntrys_aggregate_bool_exp {
  bool_and: LexEntrys_aggregate_bool_exp_bool_and
  bool_or: LexEntrys_aggregate_bool_exp_bool_or
  count: LexEntrys_aggregate_bool_exp_count
}

input LexEntrys_aggregate_bool_exp_bool_and {
  arguments: LexEntrys_select_column_LexEntrys_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: LexEntrysBoolExp
  predicate: BooleanComparisonExp!
}

input LexEntrys_aggregate_bool_exp_bool_or {
  arguments: LexEntrys_select_column_LexEntrys_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: LexEntrysBoolExp
  predicate: BooleanComparisonExp!
}

input LexEntrys_aggregate_bool_exp_count {
  arguments: [LexEntrysSelectColumn!]
  distinct: Boolean
  filter: LexEntrysBoolExp
  predicate: IntComparisonExp!
}

"""
order by avg() on columns of table "LexEntrys"
"""
input LexEntrys_avg_order_by {
  classID: OrderBy
  homographNumber: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by max() on columns of table "LexEntrys"
"""
input LexEntrys_max_order_by {
  classID: OrderBy
  dateCreated: OrderBy
  dateModified: OrderBy
  guid: OrderBy
  homographNumber: OrderBy
  hvo: OrderBy
  importResidue: OrderBy
  lexemeFormGuid: OrderBy
  liftResidue: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
}

"""
order by min() on columns of table "LexEntrys"
"""
input LexEntrys_min_order_by {
  classID: OrderBy
  dateCreated: OrderBy
  dateModified: OrderBy
  guid: OrderBy
  homographNumber: OrderBy
  hvo: OrderBy
  importResidue: OrderBy
  lexemeFormGuid: OrderBy
  liftResidue: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
}

"""
order by stddev() on columns of table "LexEntrys"
"""
input LexEntrys_stddev_order_by {
  classID: OrderBy
  homographNumber: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by stddev_pop() on columns of table "LexEntrys"
"""
input LexEntrys_stddev_pop_order_by {
  classID: OrderBy
  homographNumber: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by stddev_samp() on columns of table "LexEntrys"
"""
input LexEntrys_stddev_samp_order_by {
  classID: OrderBy
  homographNumber: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by sum() on columns of table "LexEntrys"
"""
input LexEntrys_sum_order_by {
  classID: OrderBy
  homographNumber: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by var_pop() on columns of table "LexEntrys"
"""
input LexEntrys_var_pop_order_by {
  classID: OrderBy
  homographNumber: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by var_samp() on columns of table "LexEntrys"
"""
input LexEntrys_var_samp_order_by {
  classID: OrderBy
  homographNumber: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by variance() on columns of table "LexEntrys"
"""
input LexEntrys_variance_order_by {
  classID: OrderBy
  homographNumber: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by aggregate values of table "LexExampleSentences"
"""
input LexExampleSentencesAggregateOrderBy {
  avg: LexExampleSentences_avg_order_by
  count: OrderBy
  max: LexExampleSentences_max_order_by
  min: LexExampleSentences_min_order_by
  stddev: LexExampleSentences_stddev_order_by
  stddev_pop: LexExampleSentences_stddev_pop_order_by
  stddev_samp: LexExampleSentences_stddev_samp_order_by
  sum: LexExampleSentences_sum_order_by
  var_pop: LexExampleSentences_var_pop_order_by
  var_samp: LexExampleSentences_var_samp_order_by
  variance: LexExampleSentences_variance_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input LexExampleSentencesAppendInput {
  example: jsonb
}

"""
input type for inserting array relation for remote table "LexExampleSentences"
"""
input LexExampleSentencesArrRelInsertInput {
  data: [LexExampleSentencesInsertInput!]!

  """
  upsert condition
  """
  onConflict: LexExampleSentencesOnConflict
}

"""
Boolean expression to filter rows from the table "LexExampleSentences". All fields are combined with a logical 'AND'.
"""
input LexExampleSentencesBoolExp {
  LexExtendedNote_ExamplesGuid: UuidComparisonExp
  LexSense_ExamplesGuid: UuidComparisonExp
  _and: [LexExampleSentencesBoolExp!]
  _not: LexExampleSentencesBoolExp
  _or: [LexExampleSentencesBoolExp!]
  classID: IntComparisonExp
  example: JsonbComparisonExp
  guid: UuidComparisonExp
  hvo: IntComparisonExp
  lexSense: LexSensesBoolExp
  liftResidue: StringComparisonExp
  ownOrd: IntComparisonExp
  owner: UuidComparisonExp
  owningFlid: IntComparisonExp
  reference: StringComparisonExp
  translations: TranslationsBoolExp
  translations_aggregate: Translations_aggregate_bool_exp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input LexExampleSentencesDeleteAtPathInput {
  example: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input LexExampleSentencesDeleteElemInput {
  example: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input LexExampleSentencesDeleteKeyInput {
  example: String
}

"""
input type for incrementing numeric columns in table "LexExampleSentences"
"""
input LexExampleSentencesIncInput {
  classID: Int
  hvo: Int
  ownOrd: Int
  owningFlid: Int
}

"""
input type for inserting data into table "LexExampleSentences"
"""
input LexExampleSentencesInsertInput {
  LexExtendedNote_ExamplesGuid: uuid
  LexSense_ExamplesGuid: uuid
  classID: Int
  example: jsonb
  guid: uuid
  hvo: Int
  lexSense: LexSensesObjRelInsertInput
  liftResidue: String
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  reference: String
  translations: TranslationsArrRelInsertInput
}

"""
on_conflict condition type for table "LexExampleSentences"
"""
input LexExampleSentencesOnConflict {
  constraint: LexExampleSentencesConstraint!
  update_columns: [LexExampleSentencesUpdateColumn!]! = []
  where: LexExampleSentencesBoolExp
}

"""
Ordering options when selecting data from "LexExampleSentences".
"""
input LexExampleSentencesOrderBy {
  LexExtendedNote_ExamplesGuid: OrderBy
  LexSense_ExamplesGuid: OrderBy
  classID: OrderBy
  example: OrderBy
  guid: OrderBy
  hvo: OrderBy
  lexSense: LexSensesOrderBy
  liftResidue: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
  reference: OrderBy
  translationsAggregate: TranslationsAggregateOrderBy
}

"""
primary key columns input for table: LexExampleSentences
"""
input LexExampleSentencesPkColumnsInput {
  guid: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input LexExampleSentencesPrependInput {
  example: jsonb
}

"""
input type for updating data in table "LexExampleSentences"
"""
input LexExampleSentencesSetInput {
  LexExtendedNote_ExamplesGuid: uuid
  LexSense_ExamplesGuid: uuid
  classID: Int
  example: jsonb
  guid: uuid
  hvo: Int
  liftResidue: String
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  reference: String
}

"""
Streaming cursor of the table "LexExampleSentences"
"""
input LexExampleSentencesStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: LexExampleSentencesStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input LexExampleSentencesStreamCursorValueInput {
  LexExtendedNote_ExamplesGuid: uuid
  LexSense_ExamplesGuid: uuid
  classID: Int
  example: jsonb
  guid: uuid
  hvo: Int
  liftResidue: String
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  reference: String
}

input LexExampleSentencesUpdates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: LexExampleSentencesAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: LexExampleSentencesDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: LexExampleSentencesDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: LexExampleSentencesDeleteKeyInput

  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: LexExampleSentencesIncInput

  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: LexExampleSentencesPrependInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: LexExampleSentencesSetInput

  """
  filter the rows which have to be updated
  """
  where: LexExampleSentencesBoolExp!
}

input LexExampleSentences_aggregate_bool_exp {
  count: LexExampleSentences_aggregate_bool_exp_count
}

input LexExampleSentences_aggregate_bool_exp_count {
  arguments: [LexExampleSentencesSelectColumn!]
  distinct: Boolean
  filter: LexExampleSentencesBoolExp
  predicate: IntComparisonExp!
}

"""
order by avg() on columns of table "LexExampleSentences"
"""
input LexExampleSentences_avg_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by max() on columns of table "LexExampleSentences"
"""
input LexExampleSentences_max_order_by {
  LexExtendedNote_ExamplesGuid: OrderBy
  LexSense_ExamplesGuid: OrderBy
  classID: OrderBy
  guid: OrderBy
  hvo: OrderBy
  liftResidue: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
  reference: OrderBy
}

"""
order by min() on columns of table "LexExampleSentences"
"""
input LexExampleSentences_min_order_by {
  LexExtendedNote_ExamplesGuid: OrderBy
  LexSense_ExamplesGuid: OrderBy
  classID: OrderBy
  guid: OrderBy
  hvo: OrderBy
  liftResidue: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
  reference: OrderBy
}

"""
order by stddev() on columns of table "LexExampleSentences"
"""
input LexExampleSentences_stddev_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by stddev_pop() on columns of table "LexExampleSentences"
"""
input LexExampleSentences_stddev_pop_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by stddev_samp() on columns of table "LexExampleSentences"
"""
input LexExampleSentences_stddev_samp_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by sum() on columns of table "LexExampleSentences"
"""
input LexExampleSentences_sum_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by var_pop() on columns of table "LexExampleSentences"
"""
input LexExampleSentences_var_pop_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by var_samp() on columns of table "LexExampleSentences"
"""
input LexExampleSentences_var_samp_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by variance() on columns of table "LexExampleSentences"
"""
input LexExampleSentences_variance_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by aggregate values of table "LexExtendedNotes"
"""
input LexExtendedNotesAggregateOrderBy {
  avg: LexExtendedNotes_avg_order_by
  count: OrderBy
  max: LexExtendedNotes_max_order_by
  min: LexExtendedNotes_min_order_by
  stddev: LexExtendedNotes_stddev_order_by
  stddev_pop: LexExtendedNotes_stddev_pop_order_by
  stddev_samp: LexExtendedNotes_stddev_samp_order_by
  sum: LexExtendedNotes_sum_order_by
  var_pop: LexExtendedNotes_var_pop_order_by
  var_samp: LexExtendedNotes_var_samp_order_by
  variance: LexExtendedNotes_variance_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input LexExtendedNotesAppendInput {
  discussion: jsonb
}

"""
input type for inserting array relation for remote table "LexExtendedNotes"
"""
input LexExtendedNotesArrRelInsertInput {
  data: [LexExtendedNotesInsertInput!]!

  """
  upsert condition
  """
  onConflict: LexExtendedNotesOnConflict
}

"""
Boolean expression to filter rows from the table "LexExtendedNotes". All fields are combined with a logical 'AND'.
"""
input LexExtendedNotesBoolExp {
  LexExtendedNote_ExtendedNoteTypeGuid: UuidComparisonExp
  LexSense_ExtendedNoteGuid: UuidComparisonExp
  _and: [LexExtendedNotesBoolExp!]
  _not: LexExtendedNotesBoolExp
  _or: [LexExtendedNotesBoolExp!]
  classID: IntComparisonExp
  discussion: JsonbComparisonExp
  extendedNoteTypeGuid: UuidComparisonExp
  guid: UuidComparisonExp
  hvo: IntComparisonExp
  ownOrd: IntComparisonExp
  owner: UuidComparisonExp
  owningFlid: IntComparisonExp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input LexExtendedNotesDeleteAtPathInput {
  discussion: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input LexExtendedNotesDeleteElemInput {
  discussion: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input LexExtendedNotesDeleteKeyInput {
  discussion: String
}

"""
input type for incrementing numeric columns in table "LexExtendedNotes"
"""
input LexExtendedNotesIncInput {
  classID: Int
  hvo: Int
  ownOrd: Int
  owningFlid: Int
}

"""
input type for inserting data into table "LexExtendedNotes"
"""
input LexExtendedNotesInsertInput {
  LexExtendedNote_ExtendedNoteTypeGuid: uuid
  LexSense_ExtendedNoteGuid: uuid
  classID: Int
  discussion: jsonb
  extendedNoteTypeGuid: uuid
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
}

"""
on_conflict condition type for table "LexExtendedNotes"
"""
input LexExtendedNotesOnConflict {
  constraint: LexExtendedNotesConstraint!
  update_columns: [LexExtendedNotesUpdateColumn!]! = []
  where: LexExtendedNotesBoolExp
}

"""
Ordering options when selecting data from "LexExtendedNotes".
"""
input LexExtendedNotesOrderBy {
  LexExtendedNote_ExtendedNoteTypeGuid: OrderBy
  LexSense_ExtendedNoteGuid: OrderBy
  classID: OrderBy
  discussion: OrderBy
  extendedNoteTypeGuid: OrderBy
  guid: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
}

"""
primary key columns input for table: LexExtendedNotes
"""
input LexExtendedNotesPkColumnsInput {
  guid: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input LexExtendedNotesPrependInput {
  discussion: jsonb
}

"""
input type for updating data in table "LexExtendedNotes"
"""
input LexExtendedNotesSetInput {
  LexExtendedNote_ExtendedNoteTypeGuid: uuid
  LexSense_ExtendedNoteGuid: uuid
  classID: Int
  discussion: jsonb
  extendedNoteTypeGuid: uuid
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
}

"""
Streaming cursor of the table "LexExtendedNotes"
"""
input LexExtendedNotesStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: LexExtendedNotesStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input LexExtendedNotesStreamCursorValueInput {
  LexExtendedNote_ExtendedNoteTypeGuid: uuid
  LexSense_ExtendedNoteGuid: uuid
  classID: Int
  discussion: jsonb
  extendedNoteTypeGuid: uuid
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
}

input LexExtendedNotesUpdates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: LexExtendedNotesAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: LexExtendedNotesDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: LexExtendedNotesDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: LexExtendedNotesDeleteKeyInput

  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: LexExtendedNotesIncInput

  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: LexExtendedNotesPrependInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: LexExtendedNotesSetInput

  """
  filter the rows which have to be updated
  """
  where: LexExtendedNotesBoolExp!
}

input LexExtendedNotes_aggregate_bool_exp {
  count: LexExtendedNotes_aggregate_bool_exp_count
}

input LexExtendedNotes_aggregate_bool_exp_count {
  arguments: [LexExtendedNotesSelectColumn!]
  distinct: Boolean
  filter: LexExtendedNotesBoolExp
  predicate: IntComparisonExp!
}

"""
order by avg() on columns of table "LexExtendedNotes"
"""
input LexExtendedNotes_avg_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by max() on columns of table "LexExtendedNotes"
"""
input LexExtendedNotes_max_order_by {
  LexExtendedNote_ExtendedNoteTypeGuid: OrderBy
  LexSense_ExtendedNoteGuid: OrderBy
  classID: OrderBy
  extendedNoteTypeGuid: OrderBy
  guid: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
}

"""
order by min() on columns of table "LexExtendedNotes"
"""
input LexExtendedNotes_min_order_by {
  LexExtendedNote_ExtendedNoteTypeGuid: OrderBy
  LexSense_ExtendedNoteGuid: OrderBy
  classID: OrderBy
  extendedNoteTypeGuid: OrderBy
  guid: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
}

"""
order by stddev() on columns of table "LexExtendedNotes"
"""
input LexExtendedNotes_stddev_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by stddev_pop() on columns of table "LexExtendedNotes"
"""
input LexExtendedNotes_stddev_pop_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by stddev_samp() on columns of table "LexExtendedNotes"
"""
input LexExtendedNotes_stddev_samp_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by sum() on columns of table "LexExtendedNotes"
"""
input LexExtendedNotes_sum_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by var_pop() on columns of table "LexExtendedNotes"
"""
input LexExtendedNotes_var_pop_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by var_samp() on columns of table "LexExtendedNotes"
"""
input LexExtendedNotes_var_samp_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by variance() on columns of table "LexExtendedNotes"
"""
input LexExtendedNotes_variance_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by aggregate values of table "LexSenses"
"""
input LexSensesAggregateOrderBy {
  avg: LexSenses_avg_order_by
  count: OrderBy
  max: LexSenses_max_order_by
  min: LexSenses_min_order_by
  stddev: LexSenses_stddev_order_by
  stddev_pop: LexSenses_stddev_pop_order_by
  stddev_samp: LexSenses_stddev_samp_order_by
  sum: LexSenses_sum_order_by
  var_pop: LexSenses_var_pop_order_by
  var_samp: LexSenses_var_samp_order_by
  variance: LexSenses_variance_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input LexSensesAppendInput {
  anthroNote: jsonb
  bibliography: jsonb
  definition: jsonb
  discourseNote: jsonb
  encyclopedicInfo: jsonb
  exemplar: jsonb
  generalNote: jsonb
  gloss: jsonb
  grammarNote: jsonb
  phonologyNote: jsonb
  restrictions: jsonb
  semanticsNote: jsonb
  socioLinguisticsNote: jsonb
  usageNote: jsonb
}

"""
input type for inserting array relation for remote table "LexSenses"
"""
input LexSensesArrRelInsertInput {
  data: [LexSensesInsertInput!]!

  """
  upsert condition
  """
  onConflict: LexSensesOnConflict
}

"""
Boolean expression to filter rows from the table "LexSenses". All fields are combined with a logical 'AND'.
"""
input LexSensesBoolExp {
  LexEntry_SensesGuid: UuidComparisonExp
  LexSense_MorphoSyntaxAnalysisGuid: UuidComparisonExp
  LexSense_SenseTypeGuid: UuidComparisonExp
  LexSense_SensesGuid: UuidComparisonExp
  LexSense_StatusGuid: UuidComparisonExp
  _and: [LexSensesBoolExp!]
  _not: LexSensesBoolExp
  _or: [LexSensesBoolExp!]
  anthroNote: JsonbComparisonExp
  bibliography: JsonbComparisonExp
  classID: IntComparisonExp
  definition: JsonbComparisonExp
  discourseNote: JsonbComparisonExp
  encyclopedicInfo: JsonbComparisonExp
  exemplar: JsonbComparisonExp
  generalNote: JsonbComparisonExp
  gloss: JsonbComparisonExp
  grammarNote: JsonbComparisonExp
  guid: UuidComparisonExp
  hvo: IntComparisonExp
  importResidue: StringComparisonExp
  lexEntry: LexEntrysBoolExp
  lexExampleSentences: LexExampleSentencesBoolExp
  lexExampleSentences_aggregate: LexExampleSentences_aggregate_bool_exp
  lexExtendedNotes: LexExtendedNotesBoolExp
  lexExtendedNotes_aggregate: LexExtendedNotes_aggregate_bool_exp
  liftResidue: StringComparisonExp
  moMorphSynAnalysis: MoMorphSynAnalysissBoolExp
  morphoSyntaxAnalysisGuid: UuidComparisonExp
  ownOrd: IntComparisonExp
  owner: UuidComparisonExp
  owningFlid: IntComparisonExp
  phonologyNote: JsonbComparisonExp
  restrictions: JsonbComparisonExp
  scientificName: StringComparisonExp
  semanticsNote: JsonbComparisonExp
  senseType: PossibilitysBoolExp
  senseTypeGuid: UuidComparisonExp
  socioLinguisticsNote: JsonbComparisonExp
  source: StringComparisonExp
  statusGuid: UuidComparisonExp
  usageNote: JsonbComparisonExp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input LexSensesDeleteAtPathInput {
  anthroNote: [String!]
  bibliography: [String!]
  definition: [String!]
  discourseNote: [String!]
  encyclopedicInfo: [String!]
  exemplar: [String!]
  generalNote: [String!]
  gloss: [String!]
  grammarNote: [String!]
  phonologyNote: [String!]
  restrictions: [String!]
  semanticsNote: [String!]
  socioLinguisticsNote: [String!]
  usageNote: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input LexSensesDeleteElemInput {
  anthroNote: Int
  bibliography: Int
  definition: Int
  discourseNote: Int
  encyclopedicInfo: Int
  exemplar: Int
  generalNote: Int
  gloss: Int
  grammarNote: Int
  phonologyNote: Int
  restrictions: Int
  semanticsNote: Int
  socioLinguisticsNote: Int
  usageNote: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input LexSensesDeleteKeyInput {
  anthroNote: String
  bibliography: String
  definition: String
  discourseNote: String
  encyclopedicInfo: String
  exemplar: String
  generalNote: String
  gloss: String
  grammarNote: String
  phonologyNote: String
  restrictions: String
  semanticsNote: String
  socioLinguisticsNote: String
  usageNote: String
}

"""
input type for incrementing numeric columns in table "LexSenses"
"""
input LexSensesIncInput {
  classID: Int
  hvo: Int
  ownOrd: Int
  owningFlid: Int
}

"""
input type for inserting data into table "LexSenses"
"""
input LexSensesInsertInput {
  LexEntry_SensesGuid: uuid
  LexSense_MorphoSyntaxAnalysisGuid: uuid
  LexSense_SenseTypeGuid: uuid
  LexSense_SensesGuid: uuid
  LexSense_StatusGuid: uuid
  anthroNote: jsonb
  bibliography: jsonb
  classID: Int
  definition: jsonb
  discourseNote: jsonb
  encyclopedicInfo: jsonb
  exemplar: jsonb
  generalNote: jsonb
  gloss: jsonb
  grammarNote: jsonb
  guid: uuid
  hvo: Int
  importResidue: String
  lexEntry: LexEntrysObjRelInsertInput
  lexExampleSentences: LexExampleSentencesArrRelInsertInput
  lexExtendedNotes: LexExtendedNotesArrRelInsertInput
  liftResidue: String
  moMorphSynAnalysis: MoMorphSynAnalysissObjRelInsertInput
  morphoSyntaxAnalysisGuid: uuid
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  phonologyNote: jsonb
  restrictions: jsonb
  scientificName: String
  semanticsNote: jsonb
  senseType: PossibilitysObjRelInsertInput
  senseTypeGuid: uuid
  socioLinguisticsNote: jsonb
  source: String
  statusGuid: uuid
  usageNote: jsonb
}

"""
input type for inserting object relation for remote table "LexSenses"
"""
input LexSensesObjRelInsertInput {
  data: LexSensesInsertInput!

  """
  upsert condition
  """
  onConflict: LexSensesOnConflict
}

"""
on_conflict condition type for table "LexSenses"
"""
input LexSensesOnConflict {
  constraint: LexSensesConstraint!
  update_columns: [LexSensesUpdateColumn!]! = []
  where: LexSensesBoolExp
}

"""
Ordering options when selecting data from "LexSenses".
"""
input LexSensesOrderBy {
  LexEntry_SensesGuid: OrderBy
  LexSense_MorphoSyntaxAnalysisGuid: OrderBy
  LexSense_SenseTypeGuid: OrderBy
  LexSense_SensesGuid: OrderBy
  LexSense_StatusGuid: OrderBy
  anthroNote: OrderBy
  bibliography: OrderBy
  classID: OrderBy
  definition: OrderBy
  discourseNote: OrderBy
  encyclopedicInfo: OrderBy
  exemplar: OrderBy
  generalNote: OrderBy
  gloss: OrderBy
  grammarNote: OrderBy
  guid: OrderBy
  hvo: OrderBy
  importResidue: OrderBy
  lexEntry: LexEntrysOrderBy
  lexExampleSentencesAggregate: LexExampleSentencesAggregateOrderBy
  lexExtendedNotesAggregate: LexExtendedNotesAggregateOrderBy
  liftResidue: OrderBy
  moMorphSynAnalysis: MoMorphSynAnalysissOrderBy
  morphoSyntaxAnalysisGuid: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
  phonologyNote: OrderBy
  restrictions: OrderBy
  scientificName: OrderBy
  semanticsNote: OrderBy
  senseType: PossibilitysOrderBy
  senseTypeGuid: OrderBy
  socioLinguisticsNote: OrderBy
  source: OrderBy
  statusGuid: OrderBy
  usageNote: OrderBy
}

"""
primary key columns input for table: LexSenses
"""
input LexSensesPkColumnsInput {
  guid: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input LexSensesPrependInput {
  anthroNote: jsonb
  bibliography: jsonb
  definition: jsonb
  discourseNote: jsonb
  encyclopedicInfo: jsonb
  exemplar: jsonb
  generalNote: jsonb
  gloss: jsonb
  grammarNote: jsonb
  phonologyNote: jsonb
  restrictions: jsonb
  semanticsNote: jsonb
  socioLinguisticsNote: jsonb
  usageNote: jsonb
}

"""
input type for updating data in table "LexSenses"
"""
input LexSensesSetInput {
  LexEntry_SensesGuid: uuid
  LexSense_MorphoSyntaxAnalysisGuid: uuid
  LexSense_SenseTypeGuid: uuid
  LexSense_SensesGuid: uuid
  LexSense_StatusGuid: uuid
  anthroNote: jsonb
  bibliography: jsonb
  classID: Int
  definition: jsonb
  discourseNote: jsonb
  encyclopedicInfo: jsonb
  exemplar: jsonb
  generalNote: jsonb
  gloss: jsonb
  grammarNote: jsonb
  guid: uuid
  hvo: Int
  importResidue: String
  liftResidue: String
  morphoSyntaxAnalysisGuid: uuid
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  phonologyNote: jsonb
  restrictions: jsonb
  scientificName: String
  semanticsNote: jsonb
  senseTypeGuid: uuid
  socioLinguisticsNote: jsonb
  source: String
  statusGuid: uuid
  usageNote: jsonb
}

"""
Streaming cursor of the table "LexSenses"
"""
input LexSensesStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: LexSensesStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input LexSensesStreamCursorValueInput {
  LexEntry_SensesGuid: uuid
  LexSense_MorphoSyntaxAnalysisGuid: uuid
  LexSense_SenseTypeGuid: uuid
  LexSense_SensesGuid: uuid
  LexSense_StatusGuid: uuid
  anthroNote: jsonb
  bibliography: jsonb
  classID: Int
  definition: jsonb
  discourseNote: jsonb
  encyclopedicInfo: jsonb
  exemplar: jsonb
  generalNote: jsonb
  gloss: jsonb
  grammarNote: jsonb
  guid: uuid
  hvo: Int
  importResidue: String
  liftResidue: String
  morphoSyntaxAnalysisGuid: uuid
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  phonologyNote: jsonb
  restrictions: jsonb
  scientificName: String
  semanticsNote: jsonb
  senseTypeGuid: uuid
  socioLinguisticsNote: jsonb
  source: String
  statusGuid: uuid
  usageNote: jsonb
}

input LexSensesUpdates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: LexSensesAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: LexSensesDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: LexSensesDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: LexSensesDeleteKeyInput

  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: LexSensesIncInput

  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: LexSensesPrependInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: LexSensesSetInput

  """
  filter the rows which have to be updated
  """
  where: LexSensesBoolExp!
}

input LexSenses_aggregate_bool_exp {
  count: LexSenses_aggregate_bool_exp_count
}

input LexSenses_aggregate_bool_exp_count {
  arguments: [LexSensesSelectColumn!]
  distinct: Boolean
  filter: LexSensesBoolExp
  predicate: IntComparisonExp!
}

"""
order by avg() on columns of table "LexSenses"
"""
input LexSenses_avg_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by max() on columns of table "LexSenses"
"""
input LexSenses_max_order_by {
  LexEntry_SensesGuid: OrderBy
  LexSense_MorphoSyntaxAnalysisGuid: OrderBy
  LexSense_SenseTypeGuid: OrderBy
  LexSense_SensesGuid: OrderBy
  LexSense_StatusGuid: OrderBy
  classID: OrderBy
  guid: OrderBy
  hvo: OrderBy
  importResidue: OrderBy
  liftResidue: OrderBy
  morphoSyntaxAnalysisGuid: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
  scientificName: OrderBy
  senseTypeGuid: OrderBy
  source: OrderBy
  statusGuid: OrderBy
}

"""
order by min() on columns of table "LexSenses"
"""
input LexSenses_min_order_by {
  LexEntry_SensesGuid: OrderBy
  LexSense_MorphoSyntaxAnalysisGuid: OrderBy
  LexSense_SenseTypeGuid: OrderBy
  LexSense_SensesGuid: OrderBy
  LexSense_StatusGuid: OrderBy
  classID: OrderBy
  guid: OrderBy
  hvo: OrderBy
  importResidue: OrderBy
  liftResidue: OrderBy
  morphoSyntaxAnalysisGuid: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
  scientificName: OrderBy
  senseTypeGuid: OrderBy
  source: OrderBy
  statusGuid: OrderBy
}

"""
order by stddev() on columns of table "LexSenses"
"""
input LexSenses_stddev_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by stddev_pop() on columns of table "LexSenses"
"""
input LexSenses_stddev_pop_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by stddev_samp() on columns of table "LexSenses"
"""
input LexSenses_stddev_samp_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by sum() on columns of table "LexSenses"
"""
input LexSenses_sum_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by var_pop() on columns of table "LexSenses"
"""
input LexSenses_var_pop_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by var_samp() on columns of table "LexSenses"
"""
input LexSenses_var_samp_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by variance() on columns of table "LexSenses"
"""
input LexSenses_variance_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input MoFormsAppendInput {
  form: jsonb
}

"""
Boolean expression to filter rows from the table "MoForms". All fields are combined with a logical 'AND'.
"""
input MoFormsBoolExp {
  LexEntry_AlternateFormsGuid: UuidComparisonExp
  MoAffixForm_MsEnvPartOfSpeechGuid: UuidComparisonExp
  MoForm_MorphTypeGuid: UuidComparisonExp
  MoForm_StemNameGuid: UuidComparisonExp
  _and: [MoFormsBoolExp!]
  _not: MoFormsBoolExp
  _or: [MoFormsBoolExp!]
  classID: IntComparisonExp
  discriminator: StringComparisonExp
  form: JsonbComparisonExp
  guid: UuidComparisonExp
  hvo: IntComparisonExp
  isAbstract: BooleanComparisonExp
  lexEntrys: LexEntrysBoolExp
  lexEntrys_aggregate: LexEntrys_aggregate_bool_exp
  liftResidue: StringComparisonExp
  morphType: PossibilitysBoolExp
  morphTypeGuid: UuidComparisonExp
  msEnvFeaturesGuid: UuidComparisonExp
  msEnvPartOfSpeechGuid: UuidComparisonExp
  ownOrd: IntComparisonExp
  owner: UuidComparisonExp
  owningFlid: IntComparisonExp
  partOfSpeech: PossibilitysBoolExp
  stemNameGuid: UuidComparisonExp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input MoFormsDeleteAtPathInput {
  form: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input MoFormsDeleteElemInput {
  form: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input MoFormsDeleteKeyInput {
  form: String
}

"""
input type for incrementing numeric columns in table "MoForms"
"""
input MoFormsIncInput {
  classID: Int
  hvo: Int
  ownOrd: Int
  owningFlid: Int
}

"""
input type for inserting data into table "MoForms"
"""
input MoFormsInsertInput {
  LexEntry_AlternateFormsGuid: uuid
  MoAffixForm_MsEnvPartOfSpeechGuid: uuid
  MoForm_MorphTypeGuid: uuid
  MoForm_StemNameGuid: uuid
  classID: Int
  discriminator: String
  form: jsonb
  guid: uuid
  hvo: Int
  isAbstract: Boolean
  lexEntrys: LexEntrysArrRelInsertInput
  liftResidue: String
  morphType: PossibilitysObjRelInsertInput
  morphTypeGuid: uuid
  msEnvFeaturesGuid: uuid
  msEnvPartOfSpeechGuid: uuid
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  partOfSpeech: PossibilitysObjRelInsertInput
  stemNameGuid: uuid
}

"""
input type for inserting object relation for remote table "MoForms"
"""
input MoFormsObjRelInsertInput {
  data: MoFormsInsertInput!

  """
  upsert condition
  """
  onConflict: MoFormsOnConflict
}

"""
on_conflict condition type for table "MoForms"
"""
input MoFormsOnConflict {
  constraint: MoFormsConstraint!
  update_columns: [MoFormsUpdateColumn!]! = []
  where: MoFormsBoolExp
}

"""
Ordering options when selecting data from "MoForms".
"""
input MoFormsOrderBy {
  LexEntry_AlternateFormsGuid: OrderBy
  MoAffixForm_MsEnvPartOfSpeechGuid: OrderBy
  MoForm_MorphTypeGuid: OrderBy
  MoForm_StemNameGuid: OrderBy
  classID: OrderBy
  discriminator: OrderBy
  form: OrderBy
  guid: OrderBy
  hvo: OrderBy
  isAbstract: OrderBy
  lexEntrysAggregate: LexEntrysAggregateOrderBy
  liftResidue: OrderBy
  morphType: PossibilitysOrderBy
  morphTypeGuid: OrderBy
  msEnvFeaturesGuid: OrderBy
  msEnvPartOfSpeechGuid: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
  partOfSpeech: PossibilitysOrderBy
  stemNameGuid: OrderBy
}

"""
primary key columns input for table: MoForms
"""
input MoFormsPkColumnsInput {
  guid: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input MoFormsPrependInput {
  form: jsonb
}

"""
input type for updating data in table "MoForms"
"""
input MoFormsSetInput {
  LexEntry_AlternateFormsGuid: uuid
  MoAffixForm_MsEnvPartOfSpeechGuid: uuid
  MoForm_MorphTypeGuid: uuid
  MoForm_StemNameGuid: uuid
  classID: Int
  discriminator: String
  form: jsonb
  guid: uuid
  hvo: Int
  isAbstract: Boolean
  liftResidue: String
  morphTypeGuid: uuid
  msEnvFeaturesGuid: uuid
  msEnvPartOfSpeechGuid: uuid
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  stemNameGuid: uuid
}

"""
Streaming cursor of the table "MoForms"
"""
input MoFormsStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: MoFormsStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input MoFormsStreamCursorValueInput {
  LexEntry_AlternateFormsGuid: uuid
  MoAffixForm_MsEnvPartOfSpeechGuid: uuid
  MoForm_MorphTypeGuid: uuid
  MoForm_StemNameGuid: uuid
  classID: Int
  discriminator: String
  form: jsonb
  guid: uuid
  hvo: Int
  isAbstract: Boolean
  liftResidue: String
  morphTypeGuid: uuid
  msEnvFeaturesGuid: uuid
  msEnvPartOfSpeechGuid: uuid
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  stemNameGuid: uuid
}

input MoFormsUpdates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: MoFormsAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: MoFormsDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: MoFormsDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: MoFormsDeleteKeyInput

  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: MoFormsIncInput

  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: MoFormsPrependInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: MoFormsSetInput

  """
  filter the rows which have to be updated
  """
  where: MoFormsBoolExp!
}

"""
Boolean expression to filter rows from the table "MoMorphSynAnalysiss". All fields are combined with a logical 'AND'.
"""
input MoMorphSynAnalysissBoolExp {
  LexEntry_MorphoSyntaxAnalysesGuid: UuidComparisonExp
  LfMoDerivAffMsa_MoMorphSynAnalysis_AffixCategoryGuid: UuidComparisonExp
  LfMoDerivStepMsa_MoMorphSynAnalysis_PartOfSpeechGuid: UuidComparisonExp
  LfMoStemMsa_MoMorphSynAnalysis_InflectionClassGuid: UuidComparisonExp
  LfMoStemMsa_MoMorphSynAnalysis_PartOfSpeechGuid: UuidComparisonExp
  LfMoStemMsa_MoMorphSynAnalysis_StratumGuid: UuidComparisonExp
  LfMoUnclassifiedAffixMsa_MoMorphSynAnalysis_PartOfSpeechGuid: UuidComparisonExp
  MoMorphSynAnalysis_AffixCategoryGuid: UuidComparisonExp
  MoMorphSynAnalysis_FromInflectionClassGuid: UuidComparisonExp
  MoMorphSynAnalysis_FromPartOfSpeechGuid: UuidComparisonExp
  MoMorphSynAnalysis_FromStemNameGuid: UuidComparisonExp
  MoMorphSynAnalysis_InflectionClassGuid: UuidComparisonExp
  MoMorphSynAnalysis_PartOfSpeechGuid: UuidComparisonExp
  MoMorphSynAnalysis_StratumGuid: UuidComparisonExp
  MoMorphSynAnalysis_ToInflectionClassGuid: UuidComparisonExp
  MoMorphSynAnalysis_ToPartOfSpeechGuid: UuidComparisonExp
  _and: [MoMorphSynAnalysissBoolExp!]
  _not: MoMorphSynAnalysissBoolExp
  _or: [MoMorphSynAnalysissBoolExp!]
  affixCategoryGuid: UuidComparisonExp
  classID: IntComparisonExp
  discriminator: StringComparisonExp
  fromInflectionClassGuid: UuidComparisonExp
  fromMsFeaturesGuid: UuidComparisonExp
  fromPartOfSpeech: PossibilitysBoolExp
  fromPartOfSpeechGuid: UuidComparisonExp
  fromStemNameGuid: UuidComparisonExp
  glossString: StringComparisonExp
  guid: UuidComparisonExp
  hvo: IntComparisonExp
  inflFeatsGuid: UuidComparisonExp
  inflectionClassGuid: UuidComparisonExp
  lfMoDerivAffMsaAffixCategoryGuid: UuidComparisonExp
  lfMoDerivStepMsaInflFeatsGuid: UuidComparisonExp
  lfMoDerivStepMsaPartOfSpeechGuid: UuidComparisonExp
  lfMoStemMsaInflectionClassGuid: UuidComparisonExp
  lfMoStemMsaMsFeaturesGuid: UuidComparisonExp
  lfMoStemMsaPartOfSpeechGuid: UuidComparisonExp
  lfMoStemMsaStratumGuid: UuidComparisonExp
  lfMoUnclassifiedAffixMsaPartOfSpeechGuid: UuidComparisonExp
  liftResidue: StringComparisonExp
  msFeaturesGuid: UuidComparisonExp
  ownOrd: IntComparisonExp
  owner: UuidComparisonExp
  owningFlid: IntComparisonExp
  partOfSpeech: PossibilitysBoolExp
  partOfSpeechGuid: UuidComparisonExp
  stratumGuid: UuidComparisonExp
  toInflectionClassGuid: UuidComparisonExp
  toMsFeaturesGuid: UuidComparisonExp
  toPartOfSpeech: PossibilitysBoolExp
  toPartOfSpeechGuid: UuidComparisonExp
}

"""
input type for incrementing numeric columns in table "MoMorphSynAnalysiss"
"""
input MoMorphSynAnalysissIncInput {
  classID: Int
  hvo: Int
  ownOrd: Int
  owningFlid: Int
}

"""
input type for inserting data into table "MoMorphSynAnalysiss"
"""
input MoMorphSynAnalysissInsertInput {
  LexEntry_MorphoSyntaxAnalysesGuid: uuid
  LfMoDerivAffMsa_MoMorphSynAnalysis_AffixCategoryGuid: uuid
  LfMoDerivStepMsa_MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  LfMoStemMsa_MoMorphSynAnalysis_InflectionClassGuid: uuid
  LfMoStemMsa_MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  LfMoStemMsa_MoMorphSynAnalysis_StratumGuid: uuid
  LfMoUnclassifiedAffixMsa_MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  MoMorphSynAnalysis_AffixCategoryGuid: uuid
  MoMorphSynAnalysis_FromInflectionClassGuid: uuid
  MoMorphSynAnalysis_FromPartOfSpeechGuid: uuid
  MoMorphSynAnalysis_FromStemNameGuid: uuid
  MoMorphSynAnalysis_InflectionClassGuid: uuid
  MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  MoMorphSynAnalysis_StratumGuid: uuid
  MoMorphSynAnalysis_ToInflectionClassGuid: uuid
  MoMorphSynAnalysis_ToPartOfSpeechGuid: uuid
  affixCategoryGuid: uuid
  classID: Int
  discriminator: String
  fromInflectionClassGuid: uuid
  fromMsFeaturesGuid: uuid
  fromPartOfSpeech: PossibilitysObjRelInsertInput
  fromPartOfSpeechGuid: uuid
  fromStemNameGuid: uuid
  glossString: String
  guid: uuid
  hvo: Int
  inflFeatsGuid: uuid
  inflectionClassGuid: uuid
  lfMoDerivAffMsaAffixCategoryGuid: uuid
  lfMoDerivStepMsaInflFeatsGuid: uuid
  lfMoDerivStepMsaPartOfSpeechGuid: uuid
  lfMoStemMsaInflectionClassGuid: uuid
  lfMoStemMsaMsFeaturesGuid: uuid
  lfMoStemMsaPartOfSpeechGuid: uuid
  lfMoStemMsaStratumGuid: uuid
  lfMoUnclassifiedAffixMsaPartOfSpeechGuid: uuid
  liftResidue: String
  msFeaturesGuid: uuid
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  partOfSpeech: PossibilitysObjRelInsertInput
  partOfSpeechGuid: uuid
  stratumGuid: uuid
  toInflectionClassGuid: uuid
  toMsFeaturesGuid: uuid
  toPartOfSpeech: PossibilitysObjRelInsertInput
  toPartOfSpeechGuid: uuid
}

"""
input type for inserting object relation for remote table "MoMorphSynAnalysiss"
"""
input MoMorphSynAnalysissObjRelInsertInput {
  data: MoMorphSynAnalysissInsertInput!

  """
  upsert condition
  """
  onConflict: MoMorphSynAnalysissOnConflict
}

"""
on_conflict condition type for table "MoMorphSynAnalysiss"
"""
input MoMorphSynAnalysissOnConflict {
  constraint: MoMorphSynAnalysissConstraint!
  update_columns: [MoMorphSynAnalysissUpdateColumn!]! = []
  where: MoMorphSynAnalysissBoolExp
}

"""
Ordering options when selecting data from "MoMorphSynAnalysiss".
"""
input MoMorphSynAnalysissOrderBy {
  LexEntry_MorphoSyntaxAnalysesGuid: OrderBy
  LfMoDerivAffMsa_MoMorphSynAnalysis_AffixCategoryGuid: OrderBy
  LfMoDerivStepMsa_MoMorphSynAnalysis_PartOfSpeechGuid: OrderBy
  LfMoStemMsa_MoMorphSynAnalysis_InflectionClassGuid: OrderBy
  LfMoStemMsa_MoMorphSynAnalysis_PartOfSpeechGuid: OrderBy
  LfMoStemMsa_MoMorphSynAnalysis_StratumGuid: OrderBy
  LfMoUnclassifiedAffixMsa_MoMorphSynAnalysis_PartOfSpeechGuid: OrderBy
  MoMorphSynAnalysis_AffixCategoryGuid: OrderBy
  MoMorphSynAnalysis_FromInflectionClassGuid: OrderBy
  MoMorphSynAnalysis_FromPartOfSpeechGuid: OrderBy
  MoMorphSynAnalysis_FromStemNameGuid: OrderBy
  MoMorphSynAnalysis_InflectionClassGuid: OrderBy
  MoMorphSynAnalysis_PartOfSpeechGuid: OrderBy
  MoMorphSynAnalysis_StratumGuid: OrderBy
  MoMorphSynAnalysis_ToInflectionClassGuid: OrderBy
  MoMorphSynAnalysis_ToPartOfSpeechGuid: OrderBy
  affixCategoryGuid: OrderBy
  classID: OrderBy
  discriminator: OrderBy
  fromInflectionClassGuid: OrderBy
  fromMsFeaturesGuid: OrderBy
  fromPartOfSpeech: PossibilitysOrderBy
  fromPartOfSpeechGuid: OrderBy
  fromStemNameGuid: OrderBy
  glossString: OrderBy
  guid: OrderBy
  hvo: OrderBy
  inflFeatsGuid: OrderBy
  inflectionClassGuid: OrderBy
  lfMoDerivAffMsaAffixCategoryGuid: OrderBy
  lfMoDerivStepMsaInflFeatsGuid: OrderBy
  lfMoDerivStepMsaPartOfSpeechGuid: OrderBy
  lfMoStemMsaInflectionClassGuid: OrderBy
  lfMoStemMsaMsFeaturesGuid: OrderBy
  lfMoStemMsaPartOfSpeechGuid: OrderBy
  lfMoStemMsaStratumGuid: OrderBy
  lfMoUnclassifiedAffixMsaPartOfSpeechGuid: OrderBy
  liftResidue: OrderBy
  msFeaturesGuid: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
  partOfSpeech: PossibilitysOrderBy
  partOfSpeechGuid: OrderBy
  stratumGuid: OrderBy
  toInflectionClassGuid: OrderBy
  toMsFeaturesGuid: OrderBy
  toPartOfSpeech: PossibilitysOrderBy
  toPartOfSpeechGuid: OrderBy
}

"""
primary key columns input for table: MoMorphSynAnalysiss
"""
input MoMorphSynAnalysissPkColumnsInput {
  guid: uuid!
}

"""
input type for updating data in table "MoMorphSynAnalysiss"
"""
input MoMorphSynAnalysissSetInput {
  LexEntry_MorphoSyntaxAnalysesGuid: uuid
  LfMoDerivAffMsa_MoMorphSynAnalysis_AffixCategoryGuid: uuid
  LfMoDerivStepMsa_MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  LfMoStemMsa_MoMorphSynAnalysis_InflectionClassGuid: uuid
  LfMoStemMsa_MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  LfMoStemMsa_MoMorphSynAnalysis_StratumGuid: uuid
  LfMoUnclassifiedAffixMsa_MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  MoMorphSynAnalysis_AffixCategoryGuid: uuid
  MoMorphSynAnalysis_FromInflectionClassGuid: uuid
  MoMorphSynAnalysis_FromPartOfSpeechGuid: uuid
  MoMorphSynAnalysis_FromStemNameGuid: uuid
  MoMorphSynAnalysis_InflectionClassGuid: uuid
  MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  MoMorphSynAnalysis_StratumGuid: uuid
  MoMorphSynAnalysis_ToInflectionClassGuid: uuid
  MoMorphSynAnalysis_ToPartOfSpeechGuid: uuid
  affixCategoryGuid: uuid
  classID: Int
  discriminator: String
  fromInflectionClassGuid: uuid
  fromMsFeaturesGuid: uuid
  fromPartOfSpeechGuid: uuid
  fromStemNameGuid: uuid
  glossString: String
  guid: uuid
  hvo: Int
  inflFeatsGuid: uuid
  inflectionClassGuid: uuid
  lfMoDerivAffMsaAffixCategoryGuid: uuid
  lfMoDerivStepMsaInflFeatsGuid: uuid
  lfMoDerivStepMsaPartOfSpeechGuid: uuid
  lfMoStemMsaInflectionClassGuid: uuid
  lfMoStemMsaMsFeaturesGuid: uuid
  lfMoStemMsaPartOfSpeechGuid: uuid
  lfMoStemMsaStratumGuid: uuid
  lfMoUnclassifiedAffixMsaPartOfSpeechGuid: uuid
  liftResidue: String
  msFeaturesGuid: uuid
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  partOfSpeechGuid: uuid
  stratumGuid: uuid
  toInflectionClassGuid: uuid
  toMsFeaturesGuid: uuid
  toPartOfSpeechGuid: uuid
}

"""
Streaming cursor of the table "MoMorphSynAnalysiss"
"""
input MoMorphSynAnalysissStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: MoMorphSynAnalysissStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input MoMorphSynAnalysissStreamCursorValueInput {
  LexEntry_MorphoSyntaxAnalysesGuid: uuid
  LfMoDerivAffMsa_MoMorphSynAnalysis_AffixCategoryGuid: uuid
  LfMoDerivStepMsa_MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  LfMoStemMsa_MoMorphSynAnalysis_InflectionClassGuid: uuid
  LfMoStemMsa_MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  LfMoStemMsa_MoMorphSynAnalysis_StratumGuid: uuid
  LfMoUnclassifiedAffixMsa_MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  MoMorphSynAnalysis_AffixCategoryGuid: uuid
  MoMorphSynAnalysis_FromInflectionClassGuid: uuid
  MoMorphSynAnalysis_FromPartOfSpeechGuid: uuid
  MoMorphSynAnalysis_FromStemNameGuid: uuid
  MoMorphSynAnalysis_InflectionClassGuid: uuid
  MoMorphSynAnalysis_PartOfSpeechGuid: uuid
  MoMorphSynAnalysis_StratumGuid: uuid
  MoMorphSynAnalysis_ToInflectionClassGuid: uuid
  MoMorphSynAnalysis_ToPartOfSpeechGuid: uuid
  affixCategoryGuid: uuid
  classID: Int
  discriminator: String
  fromInflectionClassGuid: uuid
  fromMsFeaturesGuid: uuid
  fromPartOfSpeechGuid: uuid
  fromStemNameGuid: uuid
  glossString: String
  guid: uuid
  hvo: Int
  inflFeatsGuid: uuid
  inflectionClassGuid: uuid
  lfMoDerivAffMsaAffixCategoryGuid: uuid
  lfMoDerivStepMsaInflFeatsGuid: uuid
  lfMoDerivStepMsaPartOfSpeechGuid: uuid
  lfMoStemMsaInflectionClassGuid: uuid
  lfMoStemMsaMsFeaturesGuid: uuid
  lfMoStemMsaPartOfSpeechGuid: uuid
  lfMoStemMsaStratumGuid: uuid
  lfMoUnclassifiedAffixMsaPartOfSpeechGuid: uuid
  liftResidue: String
  msFeaturesGuid: uuid
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  partOfSpeechGuid: uuid
  stratumGuid: uuid
  toInflectionClassGuid: uuid
  toMsFeaturesGuid: uuid
  toPartOfSpeechGuid: uuid
}

input MoMorphSynAnalysissUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: MoMorphSynAnalysissIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: MoMorphSynAnalysissSetInput

  """
  filter the rows which have to be updated
  """
  where: MoMorphSynAnalysissBoolExp!
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input NotesAppendInput {
  content: jsonb
}

"""
Boolean expression to filter rows from the table "Notes". All fields are combined with a logical 'AND'.
"""
input NotesBoolExp {
  Segment_NotesGuid: UuidComparisonExp
  _and: [NotesBoolExp!]
  _not: NotesBoolExp
  _or: [NotesBoolExp!]
  classID: IntComparisonExp
  content: JsonbComparisonExp
  guid: UuidComparisonExp
  hvo: IntComparisonExp
  ownOrd: IntComparisonExp
  owner: UuidComparisonExp
  owningFlid: IntComparisonExp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input NotesDeleteAtPathInput {
  content: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input NotesDeleteElemInput {
  content: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input NotesDeleteKeyInput {
  content: String
}

"""
input type for incrementing numeric columns in table "Notes"
"""
input NotesIncInput {
  classID: Int
  hvo: Int
  ownOrd: Int
  owningFlid: Int
}

"""
input type for inserting data into table "Notes"
"""
input NotesInsertInput {
  Segment_NotesGuid: uuid
  classID: Int
  content: jsonb
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
}

"""
on_conflict condition type for table "Notes"
"""
input NotesOnConflict {
  constraint: NotesConstraint!
  update_columns: [NotesUpdateColumn!]! = []
  where: NotesBoolExp
}

"""
Ordering options when selecting data from "Notes".
"""
input NotesOrderBy {
  Segment_NotesGuid: OrderBy
  classID: OrderBy
  content: OrderBy
  guid: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
}

"""
primary key columns input for table: Notes
"""
input NotesPkColumnsInput {
  guid: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input NotesPrependInput {
  content: jsonb
}

"""
input type for updating data in table "Notes"
"""
input NotesSetInput {
  Segment_NotesGuid: uuid
  classID: Int
  content: jsonb
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
}

"""
Streaming cursor of the table "Notes"
"""
input NotesStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: NotesStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input NotesStreamCursorValueInput {
  Segment_NotesGuid: uuid
  classID: Int
  content: jsonb
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
}

input NotesUpdates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: NotesAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: NotesDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: NotesDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: NotesDeleteKeyInput

  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: NotesIncInput

  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: NotesPrependInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: NotesSetInput

  """
  filter the rows which have to be updated
  """
  where: NotesBoolExp!
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input PossibilitysAppendInput {
  abbreviation: jsonb
  alias: jsonb
  dateOfBirth: jsonb
  dateOfDeath: jsonb
  description: jsonb
  glossAppend: jsonb
  glossPrepend: jsonb
  lfLexEntryTypeReverseName: jsonb
  lfLocationAlias: jsonb
  name: jsonb
  reverseAbbr: jsonb
  reverseAbbreviation: jsonb
  reverseName: jsonb
  seeAlso: jsonb
}

"""
Boolean expression to filter rows from the table "Possibilitys". All fields are combined with a logical 'AND'.
"""
input PossibilitysBoolExp {
  MajorObject_PossibilitiesGuid: UuidComparisonExp
  Possibility_ConfidenceGuid: UuidComparisonExp
  Possibility_DefaultInflectionClassGuid: UuidComparisonExp
  Possibility_EducationGuid: UuidComparisonExp
  Possibility_PlaceOfBirthGuid: UuidComparisonExp
  Possibility_StatusGuid: UuidComparisonExp
  Possibility_SubPossibilitiesGuid: UuidComparisonExp
  _and: [PossibilitysBoolExp!]
  _not: PossibilitysBoolExp
  _or: [PossibilitysBoolExp!]
  abbreviation: JsonbComparisonExp
  alias: JsonbComparisonExp
  allowsComment: BooleanComparisonExp
  allowsFeatureStructure: BooleanComparisonExp
  allowsInstanceOf: BooleanComparisonExp
  backColor: IntComparisonExp
  canCreateOrphan: BooleanComparisonExp
  catalogSourceId: StringComparisonExp
  classID: IntComparisonExp
  confidenceGuid: UuidComparisonExp
  copyCutPastable: BooleanComparisonExp
  dateCreated: TimestamptzComparisonExp
  dateModified: TimestamptzComparisonExp
  dateOfBirth: JsonbComparisonExp
  dateOfDeath: JsonbComparisonExp
  defaultFeaturesGuid: UuidComparisonExp
  defaultInflectionClassGuid: UuidComparisonExp
  description: JsonbComparisonExp
  discriminator: StringComparisonExp
  discussionGuid: UuidComparisonExp
  educationGuid: UuidComparisonExp
  foreColor: IntComparisonExp
  gender: IntComparisonExp
  glossAppend: JsonbComparisonExp
  glossPrepend: JsonbComparisonExp
  guid: UuidComparisonExp
  helpId: StringComparisonExp
  hidden: BooleanComparisonExp
  hvo: IntComparisonExp
  inflFeatsGuid: UuidComparisonExp
  inherFeatValGuid: UuidComparisonExp
  instanceOfSignature: IntComparisonExp
  isProtected: BooleanComparisonExp
  isResearcher: BooleanComparisonExp
  lfLexEntryTypeReverseName: JsonbComparisonExp
  lfLocationAlias: JsonbComparisonExp
  louwNidaCodes: StringComparisonExp
  mappingType: IntComparisonExp
  maxDupOccur: IntComparisonExp
  multi: BooleanComparisonExp
  name: JsonbComparisonExp
  ocmCodes: StringComparisonExp
  ownOrd: IntComparisonExp
  owner: UuidComparisonExp
  owningFlid: IntComparisonExp
  placeOfBirthGuid: UuidComparisonExp
  postfix: StringComparisonExp
  prefix: StringComparisonExp
  promptUser: BooleanComparisonExp
  reverseAbbr: JsonbComparisonExp
  reverseAbbreviation: JsonbComparisonExp
  reverseName: JsonbComparisonExp
  secondaryOrder: IntComparisonExp
  seeAlso: JsonbComparisonExp
  severity: IntComparisonExp
  sortSpec: IntComparisonExp
  statusGuid: UuidComparisonExp
  termId: IntComparisonExp
  underColor: IntComparisonExp
  underStyle: IntComparisonExp
  userCanCreate: BooleanComparisonExp
  zeroWidth: BooleanComparisonExp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input PossibilitysDeleteAtPathInput {
  abbreviation: [String!]
  alias: [String!]
  dateOfBirth: [String!]
  dateOfDeath: [String!]
  description: [String!]
  glossAppend: [String!]
  glossPrepend: [String!]
  lfLexEntryTypeReverseName: [String!]
  lfLocationAlias: [String!]
  name: [String!]
  reverseAbbr: [String!]
  reverseAbbreviation: [String!]
  reverseName: [String!]
  seeAlso: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input PossibilitysDeleteElemInput {
  abbreviation: Int
  alias: Int
  dateOfBirth: Int
  dateOfDeath: Int
  description: Int
  glossAppend: Int
  glossPrepend: Int
  lfLexEntryTypeReverseName: Int
  lfLocationAlias: Int
  name: Int
  reverseAbbr: Int
  reverseAbbreviation: Int
  reverseName: Int
  seeAlso: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input PossibilitysDeleteKeyInput {
  abbreviation: String
  alias: String
  dateOfBirth: String
  dateOfDeath: String
  description: String
  glossAppend: String
  glossPrepend: String
  lfLexEntryTypeReverseName: String
  lfLocationAlias: String
  name: String
  reverseAbbr: String
  reverseAbbreviation: String
  reverseName: String
  seeAlso: String
}

"""
input type for incrementing numeric columns in table "Possibilitys"
"""
input PossibilitysIncInput {
  backColor: Int
  classID: Int
  foreColor: Int
  gender: Int
  hvo: Int
  instanceOfSignature: Int
  mappingType: Int
  maxDupOccur: Int
  ownOrd: Int
  owningFlid: Int
  secondaryOrder: Int
  severity: Int
  sortSpec: Int
  termId: Int
  underColor: Int
  underStyle: Int
}

"""
input type for inserting data into table "Possibilitys"
"""
input PossibilitysInsertInput {
  MajorObject_PossibilitiesGuid: uuid
  Possibility_ConfidenceGuid: uuid
  Possibility_DefaultInflectionClassGuid: uuid
  Possibility_EducationGuid: uuid
  Possibility_PlaceOfBirthGuid: uuid
  Possibility_StatusGuid: uuid
  Possibility_SubPossibilitiesGuid: uuid
  abbreviation: jsonb
  alias: jsonb
  allowsComment: Boolean
  allowsFeatureStructure: Boolean
  allowsInstanceOf: Boolean
  backColor: Int
  canCreateOrphan: Boolean
  catalogSourceId: String
  classID: Int
  confidenceGuid: uuid
  copyCutPastable: Boolean
  dateCreated: timestamptz
  dateModified: timestamptz
  dateOfBirth: jsonb
  dateOfDeath: jsonb
  defaultFeaturesGuid: uuid
  defaultInflectionClassGuid: uuid
  description: jsonb
  discriminator: String
  discussionGuid: uuid
  educationGuid: uuid
  foreColor: Int
  gender: Int
  glossAppend: jsonb
  glossPrepend: jsonb
  guid: uuid
  helpId: String
  hidden: Boolean
  hvo: Int
  inflFeatsGuid: uuid
  inherFeatValGuid: uuid
  instanceOfSignature: Int
  isProtected: Boolean
  isResearcher: Boolean
  lfLexEntryTypeReverseName: jsonb
  lfLocationAlias: jsonb
  louwNidaCodes: String
  mappingType: Int
  maxDupOccur: Int
  multi: Boolean
  name: jsonb
  ocmCodes: String
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  placeOfBirthGuid: uuid
  postfix: String
  prefix: String
  promptUser: Boolean
  reverseAbbr: jsonb
  reverseAbbreviation: jsonb
  reverseName: jsonb
  secondaryOrder: Int
  seeAlso: jsonb
  severity: Int
  sortSpec: Int
  statusGuid: uuid
  termId: Int
  underColor: Int
  underStyle: Int
  userCanCreate: Boolean
  zeroWidth: Boolean
}

"""
input type for inserting object relation for remote table "Possibilitys"
"""
input PossibilitysObjRelInsertInput {
  data: PossibilitysInsertInput!

  """
  upsert condition
  """
  onConflict: PossibilitysOnConflict
}

"""
on_conflict condition type for table "Possibilitys"
"""
input PossibilitysOnConflict {
  constraint: PossibilitysConstraint!
  update_columns: [PossibilitysUpdateColumn!]! = []
  where: PossibilitysBoolExp
}

"""
Ordering options when selecting data from "Possibilitys".
"""
input PossibilitysOrderBy {
  MajorObject_PossibilitiesGuid: OrderBy
  Possibility_ConfidenceGuid: OrderBy
  Possibility_DefaultInflectionClassGuid: OrderBy
  Possibility_EducationGuid: OrderBy
  Possibility_PlaceOfBirthGuid: OrderBy
  Possibility_StatusGuid: OrderBy
  Possibility_SubPossibilitiesGuid: OrderBy
  abbreviation: OrderBy
  alias: OrderBy
  allowsComment: OrderBy
  allowsFeatureStructure: OrderBy
  allowsInstanceOf: OrderBy
  backColor: OrderBy
  canCreateOrphan: OrderBy
  catalogSourceId: OrderBy
  classID: OrderBy
  confidenceGuid: OrderBy
  copyCutPastable: OrderBy
  dateCreated: OrderBy
  dateModified: OrderBy
  dateOfBirth: OrderBy
  dateOfDeath: OrderBy
  defaultFeaturesGuid: OrderBy
  defaultInflectionClassGuid: OrderBy
  description: OrderBy
  discriminator: OrderBy
  discussionGuid: OrderBy
  educationGuid: OrderBy
  foreColor: OrderBy
  gender: OrderBy
  glossAppend: OrderBy
  glossPrepend: OrderBy
  guid: OrderBy
  helpId: OrderBy
  hidden: OrderBy
  hvo: OrderBy
  inflFeatsGuid: OrderBy
  inherFeatValGuid: OrderBy
  instanceOfSignature: OrderBy
  isProtected: OrderBy
  isResearcher: OrderBy
  lfLexEntryTypeReverseName: OrderBy
  lfLocationAlias: OrderBy
  louwNidaCodes: OrderBy
  mappingType: OrderBy
  maxDupOccur: OrderBy
  multi: OrderBy
  name: OrderBy
  ocmCodes: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
  placeOfBirthGuid: OrderBy
  postfix: OrderBy
  prefix: OrderBy
  promptUser: OrderBy
  reverseAbbr: OrderBy
  reverseAbbreviation: OrderBy
  reverseName: OrderBy
  secondaryOrder: OrderBy
  seeAlso: OrderBy
  severity: OrderBy
  sortSpec: OrderBy
  statusGuid: OrderBy
  termId: OrderBy
  underColor: OrderBy
  underStyle: OrderBy
  userCanCreate: OrderBy
  zeroWidth: OrderBy
}

"""
primary key columns input for table: Possibilitys
"""
input PossibilitysPkColumnsInput {
  guid: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input PossibilitysPrependInput {
  abbreviation: jsonb
  alias: jsonb
  dateOfBirth: jsonb
  dateOfDeath: jsonb
  description: jsonb
  glossAppend: jsonb
  glossPrepend: jsonb
  lfLexEntryTypeReverseName: jsonb
  lfLocationAlias: jsonb
  name: jsonb
  reverseAbbr: jsonb
  reverseAbbreviation: jsonb
  reverseName: jsonb
  seeAlso: jsonb
}

"""
input type for updating data in table "Possibilitys"
"""
input PossibilitysSetInput {
  MajorObject_PossibilitiesGuid: uuid
  Possibility_ConfidenceGuid: uuid
  Possibility_DefaultInflectionClassGuid: uuid
  Possibility_EducationGuid: uuid
  Possibility_PlaceOfBirthGuid: uuid
  Possibility_StatusGuid: uuid
  Possibility_SubPossibilitiesGuid: uuid
  abbreviation: jsonb
  alias: jsonb
  allowsComment: Boolean
  allowsFeatureStructure: Boolean
  allowsInstanceOf: Boolean
  backColor: Int
  canCreateOrphan: Boolean
  catalogSourceId: String
  classID: Int
  confidenceGuid: uuid
  copyCutPastable: Boolean
  dateCreated: timestamptz
  dateModified: timestamptz
  dateOfBirth: jsonb
  dateOfDeath: jsonb
  defaultFeaturesGuid: uuid
  defaultInflectionClassGuid: uuid
  description: jsonb
  discriminator: String
  discussionGuid: uuid
  educationGuid: uuid
  foreColor: Int
  gender: Int
  glossAppend: jsonb
  glossPrepend: jsonb
  guid: uuid
  helpId: String
  hidden: Boolean
  hvo: Int
  inflFeatsGuid: uuid
  inherFeatValGuid: uuid
  instanceOfSignature: Int
  isProtected: Boolean
  isResearcher: Boolean
  lfLexEntryTypeReverseName: jsonb
  lfLocationAlias: jsonb
  louwNidaCodes: String
  mappingType: Int
  maxDupOccur: Int
  multi: Boolean
  name: jsonb
  ocmCodes: String
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  placeOfBirthGuid: uuid
  postfix: String
  prefix: String
  promptUser: Boolean
  reverseAbbr: jsonb
  reverseAbbreviation: jsonb
  reverseName: jsonb
  secondaryOrder: Int
  seeAlso: jsonb
  severity: Int
  sortSpec: Int
  statusGuid: uuid
  termId: Int
  underColor: Int
  underStyle: Int
  userCanCreate: Boolean
  zeroWidth: Boolean
}

"""
Streaming cursor of the table "Possibilitys"
"""
input PossibilitysStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: PossibilitysStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input PossibilitysStreamCursorValueInput {
  MajorObject_PossibilitiesGuid: uuid
  Possibility_ConfidenceGuid: uuid
  Possibility_DefaultInflectionClassGuid: uuid
  Possibility_EducationGuid: uuid
  Possibility_PlaceOfBirthGuid: uuid
  Possibility_StatusGuid: uuid
  Possibility_SubPossibilitiesGuid: uuid
  abbreviation: jsonb
  alias: jsonb
  allowsComment: Boolean
  allowsFeatureStructure: Boolean
  allowsInstanceOf: Boolean
  backColor: Int
  canCreateOrphan: Boolean
  catalogSourceId: String
  classID: Int
  confidenceGuid: uuid
  copyCutPastable: Boolean
  dateCreated: timestamptz
  dateModified: timestamptz
  dateOfBirth: jsonb
  dateOfDeath: jsonb
  defaultFeaturesGuid: uuid
  defaultInflectionClassGuid: uuid
  description: jsonb
  discriminator: String
  discussionGuid: uuid
  educationGuid: uuid
  foreColor: Int
  gender: Int
  glossAppend: jsonb
  glossPrepend: jsonb
  guid: uuid
  helpId: String
  hidden: Boolean
  hvo: Int
  inflFeatsGuid: uuid
  inherFeatValGuid: uuid
  instanceOfSignature: Int
  isProtected: Boolean
  isResearcher: Boolean
  lfLexEntryTypeReverseName: jsonb
  lfLocationAlias: jsonb
  louwNidaCodes: String
  mappingType: Int
  maxDupOccur: Int
  multi: Boolean
  name: jsonb
  ocmCodes: String
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  placeOfBirthGuid: uuid
  postfix: String
  prefix: String
  promptUser: Boolean
  reverseAbbr: jsonb
  reverseAbbreviation: jsonb
  reverseName: jsonb
  secondaryOrder: Int
  seeAlso: jsonb
  severity: Int
  sortSpec: Int
  statusGuid: uuid
  termId: Int
  underColor: Int
  underStyle: Int
  userCanCreate: Boolean
  zeroWidth: Boolean
}

input PossibilitysUpdates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: PossibilitysAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: PossibilitysDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: PossibilitysDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: PossibilitysDeleteKeyInput

  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: PossibilitysIncInput

  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: PossibilitysPrependInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: PossibilitysSetInput

  """
  filter the rows which have to be updated
  """
  where: PossibilitysBoolExp!
}

"""
order by aggregate values of table "ProjectUsers"
"""
input ProjectUsersAggregateOrderBy {
  avg: ProjectUsers_avg_order_by
  count: OrderBy
  max: ProjectUsers_max_order_by
  min: ProjectUsers_min_order_by
  stddev: ProjectUsers_stddev_order_by
  stddev_pop: ProjectUsers_stddev_pop_order_by
  stddev_samp: ProjectUsers_stddev_samp_order_by
  sum: ProjectUsers_sum_order_by
  var_pop: ProjectUsers_var_pop_order_by
  var_samp: ProjectUsers_var_samp_order_by
  variance: ProjectUsers_variance_order_by
}

"""
input type for inserting array relation for remote table "ProjectUsers"
"""
input ProjectUsersArrRelInsertInput {
  data: [ProjectUsersInsertInput!]!

  """
  upsert condition
  """
  onConflict: ProjectUsersOnConflict
}

"""
Boolean expression to filter rows from the table "ProjectUsers". All fields are combined with a logical 'AND'.
"""
input ProjectUsersBoolExp {
  Projects: ProjectsBoolExp
  User: UsersBoolExp
  _and: [ProjectUsersBoolExp!]
  _not: ProjectUsersBoolExp
  _or: [ProjectUsersBoolExp!]
  createdDate: TimestamptzComparisonExp
  id: UuidComparisonExp
  projectId: UuidComparisonExp
  role: IntComparisonExp
  updatedDate: TimestamptzComparisonExp
  userId: UuidComparisonExp
}

"""
input type for incrementing numeric columns in table "ProjectUsers"
"""
input ProjectUsersIncInput {
  role: Int
}

"""
input type for inserting data into table "ProjectUsers"
"""
input ProjectUsersInsertInput {
  Projects: ProjectsObjRelInsertInput
  User: UsersObjRelInsertInput
  createdDate: timestamptz
  id: uuid
  projectId: uuid
  role: Int
  updatedDate: timestamptz
  userId: uuid
}

"""
on_conflict condition type for table "ProjectUsers"
"""
input ProjectUsersOnConflict {
  constraint: ProjectUsersConstraint!
  update_columns: [ProjectUsersUpdateColumn!]! = []
  where: ProjectUsersBoolExp
}

"""
Ordering options when selecting data from "ProjectUsers".
"""
input ProjectUsersOrderBy {
  Projects: ProjectsOrderBy
  User: UsersOrderBy
  createdDate: OrderBy
  id: OrderBy
  projectId: OrderBy
  role: OrderBy
  updatedDate: OrderBy
  userId: OrderBy
}

"""
primary key columns input for table: ProjectUsers
"""
input ProjectUsersPkColumnsInput {
  id: uuid!
}

"""
input type for updating data in table "ProjectUsers"
"""
input ProjectUsersSetInput {
  createdDate: timestamptz
  id: uuid
  projectId: uuid
  role: Int
  updatedDate: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "ProjectUsers"
"""
input ProjectUsersStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: ProjectUsersStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input ProjectUsersStreamCursorValueInput {
  createdDate: timestamptz
  id: uuid
  projectId: uuid
  role: Int
  updatedDate: timestamptz
  userId: uuid
}

input ProjectUsersUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: ProjectUsersIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: ProjectUsersSetInput

  """
  filter the rows which have to be updated
  """
  where: ProjectUsersBoolExp!
}

input ProjectUsers_aggregate_bool_exp {
  count: ProjectUsers_aggregate_bool_exp_count
}

input ProjectUsers_aggregate_bool_exp_count {
  arguments: [ProjectUsersSelectColumn!]
  distinct: Boolean
  filter: ProjectUsersBoolExp
  predicate: IntComparisonExp!
}

"""
order by avg() on columns of table "ProjectUsers"
"""
input ProjectUsers_avg_order_by {
  role: OrderBy
}

"""
order by max() on columns of table "ProjectUsers"
"""
input ProjectUsers_max_order_by {
  createdDate: OrderBy
  id: OrderBy
  projectId: OrderBy
  role: OrderBy
  updatedDate: OrderBy
  userId: OrderBy
}

"""
order by min() on columns of table "ProjectUsers"
"""
input ProjectUsers_min_order_by {
  createdDate: OrderBy
  id: OrderBy
  projectId: OrderBy
  role: OrderBy
  updatedDate: OrderBy
  userId: OrderBy
}

"""
order by stddev() on columns of table "ProjectUsers"
"""
input ProjectUsers_stddev_order_by {
  role: OrderBy
}

"""
order by stddev_pop() on columns of table "ProjectUsers"
"""
input ProjectUsers_stddev_pop_order_by {
  role: OrderBy
}

"""
order by stddev_samp() on columns of table "ProjectUsers"
"""
input ProjectUsers_stddev_samp_order_by {
  role: OrderBy
}

"""
order by sum() on columns of table "ProjectUsers"
"""
input ProjectUsers_sum_order_by {
  role: OrderBy
}

"""
order by var_pop() on columns of table "ProjectUsers"
"""
input ProjectUsers_var_pop_order_by {
  role: OrderBy
}

"""
order by var_samp() on columns of table "ProjectUsers"
"""
input ProjectUsers_var_samp_order_by {
  role: OrderBy
}

"""
order by variance() on columns of table "ProjectUsers"
"""
input ProjectUsers_variance_order_by {
  role: OrderBy
}

"""
Boolean expression to filter rows from the table "Projects". All fields are combined with a logical 'AND'.
"""
input ProjectsBoolExp {
  ProjectUsers: ProjectUsersBoolExp
  ProjectUsers_aggregate: ProjectUsers_aggregate_bool_exp
  _and: [ProjectsBoolExp!]
  _not: ProjectsBoolExp
  _or: [ProjectsBoolExp!]
  code: StringComparisonExp
  createdDate: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  name: StringComparisonExp
  retentionPolicy: IntComparisonExp
  type: IntComparisonExp
  updatedDate: TimestamptzComparisonExp
}

"""
input type for incrementing numeric columns in table "Projects"
"""
input ProjectsIncInput {
  retentionPolicy: Int
  type: Int
}

"""
input type for inserting data into table "Projects"
"""
input ProjectsInsertInput {
  ProjectUsers: ProjectUsersArrRelInsertInput
  code: String
  createdDate: timestamptz
  description: String
  id: uuid
  name: String
  retentionPolicy: Int
  type: Int
  updatedDate: timestamptz
}

"""
input type for inserting object relation for remote table "Projects"
"""
input ProjectsObjRelInsertInput {
  data: ProjectsInsertInput!

  """
  upsert condition
  """
  onConflict: ProjectsOnConflict
}

"""
on_conflict condition type for table "Projects"
"""
input ProjectsOnConflict {
  constraint: ProjectsConstraint!
  update_columns: [ProjectsUpdateColumn!]! = []
  where: ProjectsBoolExp
}

"""
Ordering options when selecting data from "Projects".
"""
input ProjectsOrderBy {
  code: OrderBy
  createdDate: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  projectUsersAggregate: ProjectUsersAggregateOrderBy
  retentionPolicy: OrderBy
  type: OrderBy
  updatedDate: OrderBy
}

"""
primary key columns input for table: Projects
"""
input ProjectsPkColumnsInput {
  id: uuid!
}

"""
input type for updating data in table "Projects"
"""
input ProjectsSetInput {
  code: String
  createdDate: timestamptz
  description: String
  id: uuid
  name: String
  retentionPolicy: Int
  type: Int
  updatedDate: timestamptz
}

"""
Streaming cursor of the table "Projects"
"""
input ProjectsStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: ProjectsStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input ProjectsStreamCursorValueInput {
  code: String
  createdDate: timestamptz
  description: String
  id: uuid
  name: String
  retentionPolicy: Int
  type: Int
  updatedDate: timestamptz
}

input ProjectsUpdates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: ProjectsIncInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: ProjectsSetInput

  """
  filter the rows which have to be updated
  """
  where: ProjectsBoolExp!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """
  does the column match the given pattern
  """
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
order by aggregate values of table "Translations"
"""
input TranslationsAggregateOrderBy {
  avg: Translations_avg_order_by
  count: OrderBy
  max: Translations_max_order_by
  min: Translations_min_order_by
  stddev: Translations_stddev_order_by
  stddev_pop: Translations_stddev_pop_order_by
  stddev_samp: Translations_stddev_samp_order_by
  sum: Translations_sum_order_by
  var_pop: Translations_var_pop_order_by
  var_samp: Translations_var_samp_order_by
  variance: Translations_variance_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input TranslationsAppendInput {
  status: jsonb
  translation: jsonb
}

"""
input type for inserting array relation for remote table "Translations"
"""
input TranslationsArrRelInsertInput {
  data: [TranslationsInsertInput!]!

  """
  upsert condition
  """
  onConflict: TranslationsOnConflict
}

"""
Boolean expression to filter rows from the table "Translations". All fields are combined with a logical 'AND'.
"""
input TranslationsBoolExp {
  LexExampleSentence_TranslationsGuid: UuidComparisonExp
  StPara_TranslationsGuid: UuidComparisonExp
  Translation_TypeGuid: UuidComparisonExp
  _and: [TranslationsBoolExp!]
  _not: TranslationsBoolExp
  _or: [TranslationsBoolExp!]
  classID: IntComparisonExp
  guid: UuidComparisonExp
  hvo: IntComparisonExp
  ownOrd: IntComparisonExp
  owner: UuidComparisonExp
  owningFlid: IntComparisonExp
  status: JsonbComparisonExp
  translation: JsonbComparisonExp
  typeGuid: UuidComparisonExp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input TranslationsDeleteAtPathInput {
  status: [String!]
  translation: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input TranslationsDeleteElemInput {
  status: Int
  translation: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input TranslationsDeleteKeyInput {
  status: String
  translation: String
}

"""
input type for incrementing numeric columns in table "Translations"
"""
input TranslationsIncInput {
  classID: Int
  hvo: Int
  ownOrd: Int
  owningFlid: Int
}

"""
input type for inserting data into table "Translations"
"""
input TranslationsInsertInput {
  LexExampleSentence_TranslationsGuid: uuid
  StPara_TranslationsGuid: uuid
  Translation_TypeGuid: uuid
  classID: Int
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  status: jsonb
  translation: jsonb
  typeGuid: uuid
}

"""
on_conflict condition type for table "Translations"
"""
input TranslationsOnConflict {
  constraint: TranslationsConstraint!
  update_columns: [TranslationsUpdateColumn!]! = []
  where: TranslationsBoolExp
}

"""
Ordering options when selecting data from "Translations".
"""
input TranslationsOrderBy {
  LexExampleSentence_TranslationsGuid: OrderBy
  StPara_TranslationsGuid: OrderBy
  Translation_TypeGuid: OrderBy
  classID: OrderBy
  guid: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
  status: OrderBy
  translation: OrderBy
  typeGuid: OrderBy
}

"""
primary key columns input for table: Translations
"""
input TranslationsPkColumnsInput {
  guid: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input TranslationsPrependInput {
  status: jsonb
  translation: jsonb
}

"""
input type for updating data in table "Translations"
"""
input TranslationsSetInput {
  LexExampleSentence_TranslationsGuid: uuid
  StPara_TranslationsGuid: uuid
  Translation_TypeGuid: uuid
  classID: Int
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  status: jsonb
  translation: jsonb
  typeGuid: uuid
}

"""
Streaming cursor of the table "Translations"
"""
input TranslationsStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: TranslationsStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input TranslationsStreamCursorValueInput {
  LexExampleSentence_TranslationsGuid: uuid
  StPara_TranslationsGuid: uuid
  Translation_TypeGuid: uuid
  classID: Int
  guid: uuid
  hvo: Int
  ownOrd: Int
  owner: uuid
  owningFlid: Int
  status: jsonb
  translation: jsonb
  typeGuid: uuid
}

input TranslationsUpdates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: TranslationsAppendInput

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _deleteAtPath: TranslationsDeleteAtPathInput

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _deleteElem: TranslationsDeleteElemInput

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _deleteKey: TranslationsDeleteKeyInput

  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: TranslationsIncInput

  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: TranslationsPrependInput

  """
  sets the columns of the filtered rows to the given values
  """
  _set: TranslationsSetInput

  """
  filter the rows which have to be updated
  """
  where: TranslationsBoolExp!
}

input Translations_aggregate_bool_exp {
  count: Translations_aggregate_bool_exp_count
}

input Translations_aggregate_bool_exp_count {
  arguments: [TranslationsSelectColumn!]
  distinct: Boolean
  filter: TranslationsBoolExp
  predicate: IntComparisonExp!
}

"""
order by avg() on columns of table "Translations"
"""
input Translations_avg_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by max() on columns of table "Translations"
"""
input Translations_max_order_by {
  LexExampleSentence_TranslationsGuid: OrderBy
  StPara_TranslationsGuid: OrderBy
  Translation_TypeGuid: OrderBy
  classID: OrderBy
  guid: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
  typeGuid: OrderBy
}

"""
order by min() on columns of table "Translations"
"""
input Translations_min_order_by {
  LexExampleSentence_TranslationsGuid: OrderBy
  StPara_TranslationsGuid: OrderBy
  Translation_TypeGuid: OrderBy
  classID: OrderBy
  guid: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owner: OrderBy
  owningFlid: OrderBy
  typeGuid: OrderBy
}

"""
order by stddev() on columns of table "Translations"
"""
input Translations_stddev_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by stddev_pop() on columns of table "Translations"
"""
input Translations_stddev_pop_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by stddev_samp() on columns of table "Translations"
"""
input Translations_stddev_samp_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by sum() on columns of table "Translations"
"""
input Translations_sum_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by var_pop() on columns of table "Translations"
"""
input Translations_var_pop_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by var_samp() on columns of table "Translations"
"""
input Translations_var_samp_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
order by variance() on columns of table "Translations"
"""
input Translations_variance_order_by {
  classID: OrderBy
  hvo: OrderBy
  ownOrd: OrderBy
  owningFlid: OrderBy
}

"""
Boolean expression to filter rows from the table "Users". All fields are combined with a logical 'AND'.
"""
input UsersBoolExp {
  UserProjects: ProjectUsersBoolExp
  UserProjects_aggregate: ProjectUsers_aggregate_bool_exp
  _and: [UsersBoolExp!]
  _not: UsersBoolExp
  _or: [UsersBoolExp!]
  createdDate: TimestamptzComparisonExp
  email: StringComparisonExp
  id: UuidComparisonExp
  isAdmin: BooleanComparisonExp
  name: StringComparisonExp
  passwordHash: StringComparisonExp
  salt: StringComparisonExp
  updatedDate: TimestamptzComparisonExp
  username: StringComparisonExp
}

"""
input type for inserting data into table "Users"
"""
input UsersInsertInput {
  UserProjects: ProjectUsersArrRelInsertInput
  createdDate: timestamptz
  email: String
  id: uuid
  isAdmin: Boolean
  name: String
  passwordHash: String
  salt: String
  updatedDate: timestamptz
  username: String
}

"""
input type for inserting object relation for remote table "Users"
"""
input UsersObjRelInsertInput {
  data: UsersInsertInput!

  """
  upsert condition
  """
  onConflict: UsersOnConflict
}

"""
on_conflict condition type for table "Users"
"""
input UsersOnConflict {
  constraint: UsersConstraint!
  update_columns: [UsersUpdateColumn!]! = []
  where: UsersBoolExp
}

"""
Ordering options when selecting data from "Users".
"""
input UsersOrderBy {
  createdDate: OrderBy
  email: OrderBy
  id: OrderBy
  isAdmin: OrderBy
  name: OrderBy
  passwordHash: OrderBy
  salt: OrderBy
  updatedDate: OrderBy
  userProjectsAggregate: ProjectUsersAggregateOrderBy
  username: OrderBy
}

"""
primary key columns input for table: Users
"""
input UsersPkColumnsInput {
  id: uuid!
}

"""
input type for updating data in table "Users"
"""
input UsersSetInput {
  createdDate: timestamptz
  email: String
  id: uuid
  isAdmin: Boolean
  name: String
  passwordHash: String
  salt: String
  updatedDate: timestamptz
  username: String
}

"""
Streaming cursor of the table "Users"
"""
input UsersStreamCursorInput {
  """
  Stream column input with initial value
  """
  initialValue: UsersStreamCursorValueInput!

  """
  cursor ordering
  """
  ordering: CursorOrdering
}

"""
Initial value of the column from where the streaming should start
"""
input UsersStreamCursorValueInput {
  createdDate: timestamptz
  email: String
  id: uuid
  isAdmin: Boolean
  name: String
  passwordHash: String
  salt: String
  updatedDate: timestamptz
  username: String
}

input UsersUpdates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: UsersSetInput

  """
  filter the rows which have to be updated
  """
  where: UsersBoolExp!
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidComparisonExp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _isNull: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
unique or primary key constraints on table "AgentEvaluations"
"""
enum AgentEvaluationsConstraint {
  """
  unique or primary key constraint on columns "Guid"
  """
  PK_AgentEvaluations
}

"""
select columns of table "AgentEvaluations"
"""
enum AgentEvaluationsSelectColumn {
  """
  column name
  """
  classID

  """
  column name
  """
  guid

  """
  column name
  """
  hvo

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid
}

"""
update columns of table "AgentEvaluations"
"""
enum AgentEvaluationsUpdateColumn {
  """
  column name
  """
  classID

  """
  column name
  """
  guid

  """
  column name
  """
  hvo

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid
}

"""
ordering argument of a cursor
"""
enum CursorOrdering {
  """
  ascending ordering of the cursor
  """
  ASC

  """
  descending ordering of the cursor
  """
  DESC
}

"""
unique or primary key constraints on table "LexEntrys"
"""
enum LexEntrysConstraint {
  """
  unique or primary key constraint on columns "Guid"
  """
  PK_LexEntrys
}

"""
select columns of table "LexEntrys"
"""
enum LexEntrysSelectColumn {
  """
  column name
  """
  bibliography

  """
  column name
  """
  citationForm

  """
  column name
  """
  classID

  """
  column name
  """
  comment

  """
  column name
  """
  dateCreated

  """
  column name
  """
  dateModified

  """
  column name
  """
  doNotUseForParsing

  """
  column name
  """
  guid

  """
  column name
  """
  homographNumber

  """
  column name
  """
  hvo

  """
  column name
  """
  importResidue

  """
  column name
  """
  lexemeFormGuid

  """
  column name
  """
  liftResidue

  """
  column name
  """
  literalMeaning

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid

  """
  column name
  """
  restrictions

  """
  column name
  """
  summaryDefinition
}

"""
update columns of table "LexEntrys"
"""
enum LexEntrysUpdateColumn {
  """
  column name
  """
  bibliography

  """
  column name
  """
  citationForm

  """
  column name
  """
  classID

  """
  column name
  """
  comment

  """
  column name
  """
  dateCreated

  """
  column name
  """
  dateModified

  """
  column name
  """
  doNotUseForParsing

  """
  column name
  """
  guid

  """
  column name
  """
  homographNumber

  """
  column name
  """
  hvo

  """
  column name
  """
  importResidue

  """
  column name
  """
  lexemeFormGuid

  """
  column name
  """
  liftResidue

  """
  column name
  """
  literalMeaning

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid

  """
  column name
  """
  restrictions

  """
  column name
  """
  summaryDefinition
}

"""
select "LexEntrys_aggregate_bool_exp_bool_and_arguments_columns" columns of table "LexEntrys"
"""
enum LexEntrys_select_column_LexEntrys_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  doNotUseForParsing
}

"""
select "LexEntrys_aggregate_bool_exp_bool_or_arguments_columns" columns of table "LexEntrys"
"""
enum LexEntrys_select_column_LexEntrys_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  doNotUseForParsing
}

"""
unique or primary key constraints on table "LexExampleSentences"
"""
enum LexExampleSentencesConstraint {
  """
  unique or primary key constraint on columns "Guid"
  """
  PK_LexExampleSentences
}

"""
select columns of table "LexExampleSentences"
"""
enum LexExampleSentencesSelectColumn {
  """
  column name
  """
  LexExtendedNote_ExamplesGuid

  """
  column name
  """
  LexSense_ExamplesGuid

  """
  column name
  """
  classID

  """
  column name
  """
  example

  """
  column name
  """
  guid

  """
  column name
  """
  hvo

  """
  column name
  """
  liftResidue

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid

  """
  column name
  """
  reference
}

"""
update columns of table "LexExampleSentences"
"""
enum LexExampleSentencesUpdateColumn {
  """
  column name
  """
  LexExtendedNote_ExamplesGuid

  """
  column name
  """
  LexSense_ExamplesGuid

  """
  column name
  """
  classID

  """
  column name
  """
  example

  """
  column name
  """
  guid

  """
  column name
  """
  hvo

  """
  column name
  """
  liftResidue

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid

  """
  column name
  """
  reference
}

"""
unique or primary key constraints on table "LexExtendedNotes"
"""
enum LexExtendedNotesConstraint {
  """
  unique or primary key constraint on columns "Guid"
  """
  PK_LexExtendedNotes
}

"""
select columns of table "LexExtendedNotes"
"""
enum LexExtendedNotesSelectColumn {
  """
  column name
  """
  LexExtendedNote_ExtendedNoteTypeGuid

  """
  column name
  """
  LexSense_ExtendedNoteGuid

  """
  column name
  """
  classID

  """
  column name
  """
  discussion

  """
  column name
  """
  extendedNoteTypeGuid

  """
  column name
  """
  guid

  """
  column name
  """
  hvo

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid
}

"""
update columns of table "LexExtendedNotes"
"""
enum LexExtendedNotesUpdateColumn {
  """
  column name
  """
  LexExtendedNote_ExtendedNoteTypeGuid

  """
  column name
  """
  LexSense_ExtendedNoteGuid

  """
  column name
  """
  classID

  """
  column name
  """
  discussion

  """
  column name
  """
  extendedNoteTypeGuid

  """
  column name
  """
  guid

  """
  column name
  """
  hvo

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid
}

"""
unique or primary key constraints on table "LexSenses"
"""
enum LexSensesConstraint {
  """
  unique or primary key constraint on columns "Guid"
  """
  PK_LexSenses
}

"""
select columns of table "LexSenses"
"""
enum LexSensesSelectColumn {
  """
  column name
  """
  LexEntry_SensesGuid

  """
  column name
  """
  LexSense_MorphoSyntaxAnalysisGuid

  """
  column name
  """
  LexSense_SenseTypeGuid

  """
  column name
  """
  LexSense_SensesGuid

  """
  column name
  """
  LexSense_StatusGuid

  """
  column name
  """
  anthroNote

  """
  column name
  """
  bibliography

  """
  column name
  """
  classID

  """
  column name
  """
  definition

  """
  column name
  """
  discourseNote

  """
  column name
  """
  encyclopedicInfo

  """
  column name
  """
  exemplar

  """
  column name
  """
  generalNote

  """
  column name
  """
  gloss

  """
  column name
  """
  grammarNote

  """
  column name
  """
  guid

  """
  column name
  """
  hvo

  """
  column name
  """
  importResidue

  """
  column name
  """
  liftResidue

  """
  column name
  """
  morphoSyntaxAnalysisGuid

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid

  """
  column name
  """
  phonologyNote

  """
  column name
  """
  restrictions

  """
  column name
  """
  scientificName

  """
  column name
  """
  semanticsNote

  """
  column name
  """
  senseTypeGuid

  """
  column name
  """
  socioLinguisticsNote

  """
  column name
  """
  source

  """
  column name
  """
  statusGuid

  """
  column name
  """
  usageNote
}

"""
update columns of table "LexSenses"
"""
enum LexSensesUpdateColumn {
  """
  column name
  """
  LexEntry_SensesGuid

  """
  column name
  """
  LexSense_MorphoSyntaxAnalysisGuid

  """
  column name
  """
  LexSense_SenseTypeGuid

  """
  column name
  """
  LexSense_SensesGuid

  """
  column name
  """
  LexSense_StatusGuid

  """
  column name
  """
  anthroNote

  """
  column name
  """
  bibliography

  """
  column name
  """
  classID

  """
  column name
  """
  definition

  """
  column name
  """
  discourseNote

  """
  column name
  """
  encyclopedicInfo

  """
  column name
  """
  exemplar

  """
  column name
  """
  generalNote

  """
  column name
  """
  gloss

  """
  column name
  """
  grammarNote

  """
  column name
  """
  guid

  """
  column name
  """
  hvo

  """
  column name
  """
  importResidue

  """
  column name
  """
  liftResidue

  """
  column name
  """
  morphoSyntaxAnalysisGuid

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid

  """
  column name
  """
  phonologyNote

  """
  column name
  """
  restrictions

  """
  column name
  """
  scientificName

  """
  column name
  """
  semanticsNote

  """
  column name
  """
  senseTypeGuid

  """
  column name
  """
  socioLinguisticsNote

  """
  column name
  """
  source

  """
  column name
  """
  statusGuid

  """
  column name
  """
  usageNote
}

"""
unique or primary key constraints on table "MoForms"
"""
enum MoFormsConstraint {
  """
  unique or primary key constraint on columns "Guid"
  """
  PK_MoForms
}

"""
select columns of table "MoForms"
"""
enum MoFormsSelectColumn {
  """
  column name
  """
  LexEntry_AlternateFormsGuid

  """
  column name
  """
  MoAffixForm_MsEnvPartOfSpeechGuid

  """
  column name
  """
  MoForm_MorphTypeGuid

  """
  column name
  """
  MoForm_StemNameGuid

  """
  column name
  """
  classID

  """
  column name
  """
  discriminator

  """
  column name
  """
  form

  """
  column name
  """
  guid

  """
  column name
  """
  hvo

  """
  column name
  """
  isAbstract

  """
  column name
  """
  liftResidue

  """
  column name
  """
  morphTypeGuid

  """
  column name
  """
  msEnvFeaturesGuid

  """
  column name
  """
  msEnvPartOfSpeechGuid

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid

  """
  column name
  """
  stemNameGuid
}

"""
update columns of table "MoForms"
"""
enum MoFormsUpdateColumn {
  """
  column name
  """
  LexEntry_AlternateFormsGuid

  """
  column name
  """
  MoAffixForm_MsEnvPartOfSpeechGuid

  """
  column name
  """
  MoForm_MorphTypeGuid

  """
  column name
  """
  MoForm_StemNameGuid

  """
  column name
  """
  classID

  """
  column name
  """
  discriminator

  """
  column name
  """
  form

  """
  column name
  """
  guid

  """
  column name
  """
  hvo

  """
  column name
  """
  isAbstract

  """
  column name
  """
  liftResidue

  """
  column name
  """
  morphTypeGuid

  """
  column name
  """
  msEnvFeaturesGuid

  """
  column name
  """
  msEnvPartOfSpeechGuid

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid

  """
  column name
  """
  stemNameGuid
}

"""
unique or primary key constraints on table "MoMorphSynAnalysiss"
"""
enum MoMorphSynAnalysissConstraint {
  """
  unique or primary key constraint on columns "Guid"
  """
  PK_MoMorphSynAnalysiss
}

"""
select columns of table "MoMorphSynAnalysiss"
"""
enum MoMorphSynAnalysissSelectColumn {
  """
  column name
  """
  LexEntry_MorphoSyntaxAnalysesGuid

  """
  column name
  """
  LfMoDerivAffMsa_MoMorphSynAnalysis_AffixCategoryGuid

  """
  column name
  """
  LfMoDerivStepMsa_MoMorphSynAnalysis_PartOfSpeechGuid

  """
  column name
  """
  LfMoStemMsa_MoMorphSynAnalysis_InflectionClassGuid

  """
  column name
  """
  LfMoStemMsa_MoMorphSynAnalysis_PartOfSpeechGuid

  """
  column name
  """
  LfMoStemMsa_MoMorphSynAnalysis_StratumGuid

  """
  column name
  """
  LfMoUnclassifiedAffixMsa_MoMorphSynAnalysis_PartOfSpeechGuid

  """
  column name
  """
  MoMorphSynAnalysis_AffixCategoryGuid

  """
  column name
  """
  MoMorphSynAnalysis_FromInflectionClassGuid

  """
  column name
  """
  MoMorphSynAnalysis_FromPartOfSpeechGuid

  """
  column name
  """
  MoMorphSynAnalysis_FromStemNameGuid

  """
  column name
  """
  MoMorphSynAnalysis_InflectionClassGuid

  """
  column name
  """
  MoMorphSynAnalysis_PartOfSpeechGuid

  """
  column name
  """
  MoMorphSynAnalysis_StratumGuid

  """
  column name
  """
  MoMorphSynAnalysis_ToInflectionClassGuid

  """
  column name
  """
  MoMorphSynAnalysis_ToPartOfSpeechGuid

  """
  column name
  """
  affixCategoryGuid

  """
  column name
  """
  classID

  """
  column name
  """
  discriminator

  """
  column name
  """
  fromInflectionClassGuid

  """
  column name
  """
  fromMsFeaturesGuid

  """
  column name
  """
  fromPartOfSpeechGuid

  """
  column name
  """
  fromStemNameGuid

  """
  column name
  """
  glossString

  """
  column name
  """
  guid

  """
  column name
  """
  hvo

  """
  column name
  """
  inflFeatsGuid

  """
  column name
  """
  inflectionClassGuid

  """
  column name
  """
  lfMoDerivAffMsaAffixCategoryGuid

  """
  column name
  """
  lfMoDerivStepMsaInflFeatsGuid

  """
  column name
  """
  lfMoDerivStepMsaPartOfSpeechGuid

  """
  column name
  """
  lfMoStemMsaInflectionClassGuid

  """
  column name
  """
  lfMoStemMsaMsFeaturesGuid

  """
  column name
  """
  lfMoStemMsaPartOfSpeechGuid

  """
  column name
  """
  lfMoStemMsaStratumGuid

  """
  column name
  """
  lfMoUnclassifiedAffixMsaPartOfSpeechGuid

  """
  column name
  """
  liftResidue

  """
  column name
  """
  msFeaturesGuid

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid

  """
  column name
  """
  partOfSpeechGuid

  """
  column name
  """
  stratumGuid

  """
  column name
  """
  toInflectionClassGuid

  """
  column name
  """
  toMsFeaturesGuid

  """
  column name
  """
  toPartOfSpeechGuid
}

"""
update columns of table "MoMorphSynAnalysiss"
"""
enum MoMorphSynAnalysissUpdateColumn {
  """
  column name
  """
  LexEntry_MorphoSyntaxAnalysesGuid

  """
  column name
  """
  LfMoDerivAffMsa_MoMorphSynAnalysis_AffixCategoryGuid

  """
  column name
  """
  LfMoDerivStepMsa_MoMorphSynAnalysis_PartOfSpeechGuid

  """
  column name
  """
  LfMoStemMsa_MoMorphSynAnalysis_InflectionClassGuid

  """
  column name
  """
  LfMoStemMsa_MoMorphSynAnalysis_PartOfSpeechGuid

  """
  column name
  """
  LfMoStemMsa_MoMorphSynAnalysis_StratumGuid

  """
  column name
  """
  LfMoUnclassifiedAffixMsa_MoMorphSynAnalysis_PartOfSpeechGuid

  """
  column name
  """
  MoMorphSynAnalysis_AffixCategoryGuid

  """
  column name
  """
  MoMorphSynAnalysis_FromInflectionClassGuid

  """
  column name
  """
  MoMorphSynAnalysis_FromPartOfSpeechGuid

  """
  column name
  """
  MoMorphSynAnalysis_FromStemNameGuid

  """
  column name
  """
  MoMorphSynAnalysis_InflectionClassGuid

  """
  column name
  """
  MoMorphSynAnalysis_PartOfSpeechGuid

  """
  column name
  """
  MoMorphSynAnalysis_StratumGuid

  """
  column name
  """
  MoMorphSynAnalysis_ToInflectionClassGuid

  """
  column name
  """
  MoMorphSynAnalysis_ToPartOfSpeechGuid

  """
  column name
  """
  affixCategoryGuid

  """
  column name
  """
  classID

  """
  column name
  """
  discriminator

  """
  column name
  """
  fromInflectionClassGuid

  """
  column name
  """
  fromMsFeaturesGuid

  """
  column name
  """
  fromPartOfSpeechGuid

  """
  column name
  """
  fromStemNameGuid

  """
  column name
  """
  glossString

  """
  column name
  """
  guid

  """
  column name
  """
  hvo

  """
  column name
  """
  inflFeatsGuid

  """
  column name
  """
  inflectionClassGuid

  """
  column name
  """
  lfMoDerivAffMsaAffixCategoryGuid

  """
  column name
  """
  lfMoDerivStepMsaInflFeatsGuid

  """
  column name
  """
  lfMoDerivStepMsaPartOfSpeechGuid

  """
  column name
  """
  lfMoStemMsaInflectionClassGuid

  """
  column name
  """
  lfMoStemMsaMsFeaturesGuid

  """
  column name
  """
  lfMoStemMsaPartOfSpeechGuid

  """
  column name
  """
  lfMoStemMsaStratumGuid

  """
  column name
  """
  lfMoUnclassifiedAffixMsaPartOfSpeechGuid

  """
  column name
  """
  liftResidue

  """
  column name
  """
  msFeaturesGuid

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid

  """
  column name
  """
  partOfSpeechGuid

  """
  column name
  """
  stratumGuid

  """
  column name
  """
  toInflectionClassGuid

  """
  column name
  """
  toMsFeaturesGuid

  """
  column name
  """
  toPartOfSpeechGuid
}

"""
unique or primary key constraints on table "Notes"
"""
enum NotesConstraint {
  """
  unique or primary key constraint on columns "Guid"
  """
  PK_Notes
}

"""
select columns of table "Notes"
"""
enum NotesSelectColumn {
  """
  column name
  """
  Segment_NotesGuid

  """
  column name
  """
  classID

  """
  column name
  """
  content

  """
  column name
  """
  guid

  """
  column name
  """
  hvo

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid
}

"""
update columns of table "Notes"
"""
enum NotesUpdateColumn {
  """
  column name
  """
  Segment_NotesGuid

  """
  column name
  """
  classID

  """
  column name
  """
  content

  """
  column name
  """
  guid

  """
  column name
  """
  hvo

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid
}

"""
column ordering options
"""
enum OrderBy {
  """
  in ascending order, nulls last
  """
  ASC

  """
  in ascending order, nulls first
  """
  ASC_NULLS_FIRST

  """
  in ascending order, nulls last
  """
  ASC_NULLS_LAST

  """
  in descending order, nulls first
  """
  DESC

  """
  in descending order, nulls first
  """
  DESC_NULLS_FIRST

  """
  in descending order, nulls last
  """
  DESC_NULLS_LAST
}

"""
unique or primary key constraints on table "Possibilitys"
"""
enum PossibilitysConstraint {
  """
  unique or primary key constraint on columns "Guid"
  """
  PK_Possibilitys
}

"""
select columns of table "Possibilitys"
"""
enum PossibilitysSelectColumn {
  """
  column name
  """
  MajorObject_PossibilitiesGuid

  """
  column name
  """
  Possibility_ConfidenceGuid

  """
  column name
  """
  Possibility_DefaultInflectionClassGuid

  """
  column name
  """
  Possibility_EducationGuid

  """
  column name
  """
  Possibility_PlaceOfBirthGuid

  """
  column name
  """
  Possibility_StatusGuid

  """
  column name
  """
  Possibility_SubPossibilitiesGuid

  """
  column name
  """
  abbreviation

  """
  column name
  """
  alias

  """
  column name
  """
  allowsComment

  """
  column name
  """
  allowsFeatureStructure

  """
  column name
  """
  allowsInstanceOf

  """
  column name
  """
  backColor

  """
  column name
  """
  canCreateOrphan

  """
  column name
  """
  catalogSourceId

  """
  column name
  """
  classID

  """
  column name
  """
  confidenceGuid

  """
  column name
  """
  copyCutPastable

  """
  column name
  """
  dateCreated

  """
  column name
  """
  dateModified

  """
  column name
  """
  dateOfBirth

  """
  column name
  """
  dateOfDeath

  """
  column name
  """
  defaultFeaturesGuid

  """
  column name
  """
  defaultInflectionClassGuid

  """
  column name
  """
  description

  """
  column name
  """
  discriminator

  """
  column name
  """
  discussionGuid

  """
  column name
  """
  educationGuid

  """
  column name
  """
  foreColor

  """
  column name
  """
  gender

  """
  column name
  """
  glossAppend

  """
  column name
  """
  glossPrepend

  """
  column name
  """
  guid

  """
  column name
  """
  helpId

  """
  column name
  """
  hidden

  """
  column name
  """
  hvo

  """
  column name
  """
  inflFeatsGuid

  """
  column name
  """
  inherFeatValGuid

  """
  column name
  """
  instanceOfSignature

  """
  column name
  """
  isProtected

  """
  column name
  """
  isResearcher

  """
  column name
  """
  lfLexEntryTypeReverseName

  """
  column name
  """
  lfLocationAlias

  """
  column name
  """
  louwNidaCodes

  """
  column name
  """
  mappingType

  """
  column name
  """
  maxDupOccur

  """
  column name
  """
  multi

  """
  column name
  """
  name

  """
  column name
  """
  ocmCodes

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid

  """
  column name
  """
  placeOfBirthGuid

  """
  column name
  """
  postfix

  """
  column name
  """
  prefix

  """
  column name
  """
  promptUser

  """
  column name
  """
  reverseAbbr

  """
  column name
  """
  reverseAbbreviation

  """
  column name
  """
  reverseName

  """
  column name
  """
  secondaryOrder

  """
  column name
  """
  seeAlso

  """
  column name
  """
  severity

  """
  column name
  """
  sortSpec

  """
  column name
  """
  statusGuid

  """
  column name
  """
  termId

  """
  column name
  """
  underColor

  """
  column name
  """
  underStyle

  """
  column name
  """
  userCanCreate

  """
  column name
  """
  zeroWidth
}

"""
update columns of table "Possibilitys"
"""
enum PossibilitysUpdateColumn {
  """
  column name
  """
  MajorObject_PossibilitiesGuid

  """
  column name
  """
  Possibility_ConfidenceGuid

  """
  column name
  """
  Possibility_DefaultInflectionClassGuid

  """
  column name
  """
  Possibility_EducationGuid

  """
  column name
  """
  Possibility_PlaceOfBirthGuid

  """
  column name
  """
  Possibility_StatusGuid

  """
  column name
  """
  Possibility_SubPossibilitiesGuid

  """
  column name
  """
  abbreviation

  """
  column name
  """
  alias

  """
  column name
  """
  allowsComment

  """
  column name
  """
  allowsFeatureStructure

  """
  column name
  """
  allowsInstanceOf

  """
  column name
  """
  backColor

  """
  column name
  """
  canCreateOrphan

  """
  column name
  """
  catalogSourceId

  """
  column name
  """
  classID

  """
  column name
  """
  confidenceGuid

  """
  column name
  """
  copyCutPastable

  """
  column name
  """
  dateCreated

  """
  column name
  """
  dateModified

  """
  column name
  """
  dateOfBirth

  """
  column name
  """
  dateOfDeath

  """
  column name
  """
  defaultFeaturesGuid

  """
  column name
  """
  defaultInflectionClassGuid

  """
  column name
  """
  description

  """
  column name
  """
  discriminator

  """
  column name
  """
  discussionGuid

  """
  column name
  """
  educationGuid

  """
  column name
  """
  foreColor

  """
  column name
  """
  gender

  """
  column name
  """
  glossAppend

  """
  column name
  """
  glossPrepend

  """
  column name
  """
  guid

  """
  column name
  """
  helpId

  """
  column name
  """
  hidden

  """
  column name
  """
  hvo

  """
  column name
  """
  inflFeatsGuid

  """
  column name
  """
  inherFeatValGuid

  """
  column name
  """
  instanceOfSignature

  """
  column name
  """
  isProtected

  """
  column name
  """
  isResearcher

  """
  column name
  """
  lfLexEntryTypeReverseName

  """
  column name
  """
  lfLocationAlias

  """
  column name
  """
  louwNidaCodes

  """
  column name
  """
  mappingType

  """
  column name
  """
  maxDupOccur

  """
  column name
  """
  multi

  """
  column name
  """
  name

  """
  column name
  """
  ocmCodes

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid

  """
  column name
  """
  placeOfBirthGuid

  """
  column name
  """
  postfix

  """
  column name
  """
  prefix

  """
  column name
  """
  promptUser

  """
  column name
  """
  reverseAbbr

  """
  column name
  """
  reverseAbbreviation

  """
  column name
  """
  reverseName

  """
  column name
  """
  secondaryOrder

  """
  column name
  """
  seeAlso

  """
  column name
  """
  severity

  """
  column name
  """
  sortSpec

  """
  column name
  """
  statusGuid

  """
  column name
  """
  termId

  """
  column name
  """
  underColor

  """
  column name
  """
  underStyle

  """
  column name
  """
  userCanCreate

  """
  column name
  """
  zeroWidth
}

"""
unique or primary key constraints on table "ProjectUsers"
"""
enum ProjectUsersConstraint {
  """
  unique or primary key constraint on columns "Id"
  """
  PK_ProjectUsers
}

"""
select columns of table "ProjectUsers"
"""
enum ProjectUsersSelectColumn {
  """
  column name
  """
  createdDate

  """
  column name
  """
  id

  """
  column name
  """
  projectId

  """
  column name
  """
  role

  """
  column name
  """
  updatedDate

  """
  column name
  """
  userId
}

"""
update columns of table "ProjectUsers"
"""
enum ProjectUsersUpdateColumn {
  """
  column name
  """
  createdDate

  """
  column name
  """
  id

  """
  column name
  """
  projectId

  """
  column name
  """
  role

  """
  column name
  """
  updatedDate

  """
  column name
  """
  userId
}

"""
unique or primary key constraints on table "Projects"
"""
enum ProjectsConstraint {
  """
  unique or primary key constraint on columns "Code"
  """
  IX_Projects_Code

  """
  unique or primary key constraint on columns "Id"
  """
  PK_Projects
}

"""
select columns of table "Projects"
"""
enum ProjectsSelectColumn {
  """
  column name
  """
  code

  """
  column name
  """
  createdDate

  """
  column name
  """
  description

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  retentionPolicy

  """
  column name
  """
  type

  """
  column name
  """
  updatedDate
}

"""
update columns of table "Projects"
"""
enum ProjectsUpdateColumn {
  """
  column name
  """
  code

  """
  column name
  """
  createdDate

  """
  column name
  """
  description

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  retentionPolicy

  """
  column name
  """
  type

  """
  column name
  """
  updatedDate
}

"""
unique or primary key constraints on table "Translations"
"""
enum TranslationsConstraint {
  """
  unique or primary key constraint on columns "Guid"
  """
  PK_Translations
}

"""
select columns of table "Translations"
"""
enum TranslationsSelectColumn {
  """
  column name
  """
  LexExampleSentence_TranslationsGuid

  """
  column name
  """
  StPara_TranslationsGuid

  """
  column name
  """
  Translation_TypeGuid

  """
  column name
  """
  classID

  """
  column name
  """
  guid

  """
  column name
  """
  hvo

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid

  """
  column name
  """
  status

  """
  column name
  """
  translation

  """
  column name
  """
  typeGuid
}

"""
update columns of table "Translations"
"""
enum TranslationsUpdateColumn {
  """
  column name
  """
  LexExampleSentence_TranslationsGuid

  """
  column name
  """
  StPara_TranslationsGuid

  """
  column name
  """
  Translation_TypeGuid

  """
  column name
  """
  classID

  """
  column name
  """
  guid

  """
  column name
  """
  hvo

  """
  column name
  """
  ownOrd

  """
  column name
  """
  owner

  """
  column name
  """
  owningFlid

  """
  column name
  """
  status

  """
  column name
  """
  translation

  """
  column name
  """
  typeGuid
}

"""
unique or primary key constraints on table "Users"
"""
enum UsersConstraint {
  """
  unique or primary key constraint on columns "Id"
  """
  PK_Users
}

"""
select columns of table "Users"
"""
enum UsersSelectColumn {
  """
  column name
  """
  createdDate

  """
  column name
  """
  email

  """
  column name
  """
  id

  """
  column name
  """
  isAdmin

  """
  column name
  """
  name

  """
  column name
  """
  passwordHash

  """
  column name
  """
  salt

  """
  column name
  """
  updatedDate

  """
  column name
  """
  username
}

"""
update columns of table "Users"
"""
enum UsersUpdateColumn {
  """
  column name
  """
  createdDate

  """
  column name
  """
  email

  """
  column name
  """
  id

  """
  column name
  """
  isAdmin

  """
  column name
  """
  name

  """
  column name
  """
  passwordHash

  """
  column name
  """
  salt

  """
  column name
  """
  updatedDate

  """
  column name
  """
  username
}

type AuthUserProject {
  code: String!
  role: ProjectRole!
}

type LexAuthUser {
  id: UUID!
  email: String!
  role: UserRole!
  projects: [AuthUserProject!]!
}

type Project {
  code: String!
  name: String!
  description: String
  retentionPolicy: RetentionPolicy!
  type: ProjectType!
  users: [LexBox_ProjectUsers!]!
  id: UUID!
  createdDate: DateTime!
  updatedDate: DateTime!
}

type User {
  name: String!
  email: String!
  isAdmin: Boolean!
  passwordHash: String!
  salt: String!
  username: String
  projects: [LexBox_ProjectUsers!]!
  id: UUID!
  createdDate: DateTime!
  updatedDate: DateTime!
}

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

input CreateProjectInput {
  name: String!
  description: String!
  code: String!
  type: ProjectType!
  retentionPolicy: RetentionPolicy!
}

input DateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime]
  nin: [DateTime]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input ListFilterInputTypeOfProjectUsersFilterInput {
  all: ProjectUsersFilterInput
  none: ProjectUsersFilterInput
  some: ProjectUsersFilterInput
  any: Boolean
}

input ProjectFilterInput {
  and: [ProjectFilterInput!]
  or: [ProjectFilterInput!]
  code: StringOperationFilterInput
  name: StringOperationFilterInput
  description: StringOperationFilterInput
  retentionPolicy: RetentionPolicyOperationFilterInput
  type: ProjectTypeOperationFilterInput
  users: ListFilterInputTypeOfProjectUsersFilterInput
  id: UuidOperationFilterInput
  createdDate: DateTimeOperationFilterInput
  updatedDate: DateTimeOperationFilterInput
}

input ProjectRoleOperationFilterInput {
  eq: ProjectRole
  neq: ProjectRole
  in: [ProjectRole!]
  nin: [ProjectRole!]
}

input ProjectTypeOperationFilterInput {
  eq: ProjectType
  neq: ProjectType
  in: [ProjectType!]
  nin: [ProjectType!]
}

input ProjectUsersFilterInput {
  and: [ProjectUsersFilterInput!]
  or: [ProjectUsersFilterInput!]
  userId: UuidOperationFilterInput
  projectId: UuidOperationFilterInput
  role: ProjectRoleOperationFilterInput
  user: UserFilterInput
  project: ProjectFilterInput
  id: UuidOperationFilterInput
  createdDate: DateTimeOperationFilterInput
  updatedDate: DateTimeOperationFilterInput
}

input RetentionPolicyOperationFilterInput {
  eq: RetentionPolicy
  neq: RetentionPolicy
  in: [RetentionPolicy!]
  nin: [RetentionPolicy!]
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

input UserFilterInput {
  and: [UserFilterInput!]
  or: [UserFilterInput!]
  name: StringOperationFilterInput
  email: StringOperationFilterInput
  isAdmin: BooleanOperationFilterInput
  passwordHash: StringOperationFilterInput
  salt: StringOperationFilterInput
  username: StringOperationFilterInput
  projects: ListFilterInputTypeOfProjectUsersFilterInput
  id: UuidOperationFilterInput
  createdDate: DateTimeOperationFilterInput
  updatedDate: DateTimeOperationFilterInput
}

input UuidOperationFilterInput {
  eq: UUID
  neq: UUID
  in: [UUID]
  nin: [UUID]
  gt: UUID
  ngt: UUID
  gte: UUID
  ngte: UUID
  lt: UUID
  nlt: UUID
  lte: UUID
  nlte: UUID
}

enum ProjectRole {
  UNKNOWN
  MANAGER
  EDITOR
}

enum ProjectType {
  UNKNOWN
  FL_EX
}

enum RetentionPolicy {
  UNKNOWN
  VERIFIED
  TEST
  DEV
}

enum UserRole {
  ADMIN
  USER
}
